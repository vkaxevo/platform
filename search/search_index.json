{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Seriously fast decentralized applications for the Dash network Dash Platform is a technology stack for building decentralized applications on the Dash network. The two main architectural components, Drive and DAPI, turn the Dash P2P network into a cloud that developers can integrate with their applications. If you are looking for how to contribute to the project or need any help with building an app on the Dash Platform - message us on the Devs Discord !","title":"Home"},{"location":"DAPI-Client/","text":"DAPI-Client Client library used to access Dash DAPI endpoints This library enables HTTP-based interaction with the Dash blockchain and Dash Platform via the decentralized API ( DAPI ) hosted on Dash masternodes. DAPI-Client provides automatic server (masternode) discovery using either a default seed node or a user-supplied one DAPI-Client maps to DAPI's RPC and gRPC endpoints Install ES5/ES6 via NPM In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/dapi-client CDN Standalone For browser usage, you can also directly rely on unpkg : <script src=\"https://unpkg.com/@dashevo/dapi-client\"></script> Licence MIT \u00a9 Dash Core Group, Inc.","title":"Index"},{"location":"DAPI-Client/#dapi-client","text":"Client library used to access Dash DAPI endpoints This library enables HTTP-based interaction with the Dash blockchain and Dash Platform via the decentralized API ( DAPI ) hosted on Dash masternodes. DAPI-Client provides automatic server (masternode) discovery using either a default seed node or a user-supplied one DAPI-Client maps to DAPI's RPC and gRPC endpoints","title":"DAPI-Client"},{"location":"DAPI-Client/#install","text":"","title":"Install"},{"location":"DAPI-Client/#es5es6-via-npm","text":"In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/dapi-client","title":"ES5/ES6 via NPM"},{"location":"DAPI-Client/#cdn-standalone","text":"For browser usage, you can also directly rely on unpkg : <script src=\"https://unpkg.com/@dashevo/dapi-client\"></script>","title":"CDN Standalone"},{"location":"DAPI-Client/#licence","text":"MIT \u00a9 Dash Core Group, Inc.","title":"Licence"},{"location":"DAPI-Client/Overview/","text":"Getting started Quick start Usage DAPIClient new DAPIClient() Core .broadcastTransaction() .generateToAddress() .getBestBlockHash() .getBlockByHash() .getBlockByHeight() .getBlockHash() .getMnListDiff() .getStatus() .getTransaction() .subscribeToTransactionsWithProofs() Platform .broadcastStateTransition() .getDataContract() .getDocuments() .getIdentityByFirstPublicKey() .getIdentity() .getIdentityIdByFirstPublicKey() License","title":"Overview"},{"location":"DAPI-Client/getting-started/quickstart/","text":"Quick start ES5/ES6 via NPM In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/dapi-client CDN Standalone For browser usage, you can also directly rely on unpkg : <script src=\"https://unpkg.com/@dashevo/dapi-client\"></script> You can see an example usage here Initialization const DAPIClient = require('@dashevo/dapi-client'); const client = new DAPIClient(); (async () => { const bestBlockHash = await client.core.getBestBlockHash(); console.log(bestBlockHash); })(); Quicknotes This package allows you to fetch & send information from both the payment chain (layer 1) and the application chain (layer 2, a.k.a Platform chain).","title":"Quick start"},{"location":"DAPI-Client/getting-started/quickstart/#quick-start","text":"","title":"Quick start"},{"location":"DAPI-Client/getting-started/quickstart/#es5es6-via-npm","text":"In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/dapi-client","title":"ES5/ES6 via NPM"},{"location":"DAPI-Client/getting-started/quickstart/#cdn-standalone","text":"For browser usage, you can also directly rely on unpkg : <script src=\"https://unpkg.com/@dashevo/dapi-client\"></script> You can see an example usage here","title":"CDN Standalone"},{"location":"DAPI-Client/getting-started/quickstart/#initialization","text":"const DAPIClient = require('@dashevo/dapi-client'); const client = new DAPIClient(); (async () => { const bestBlockHash = await client.core.getBestBlockHash(); console.log(bestBlockHash); })();","title":"Initialization"},{"location":"DAPI-Client/getting-started/quickstart/#quicknotes","text":"This package allows you to fetch & send information from both the payment chain (layer 1) and the application chain (layer 2, a.k.a Platform chain).","title":"Quicknotes"},{"location":"DAPI-Client/usage/application/DAPIClient/","text":"Usage : new DAPIClient(options) Description : This method creates a new DAPIClient instance. Parameters: parameters type required[def value] Description options Object options.dapiAddressProvider DAPIAddressProvider no[ListDAPIAddressProvider] Allow to override the default dapiAddressProvider (do not allow seeds or dapiAddresses params) options.seeds string[] no[seeds] Allow to override default seeds (to connect to specific node) options.network string Network no[=evonet] options.timeout number no[=2000] Used to specify the timeout time in milliseconds. options.retries number no[=3] Used to specify the number of retries before aborting and erroring a request. options.baseBanTime number no[=6000] Returns : DAPIClient instance. const DAPIClient = require('@dashevo/dapi-client'); const client = new DAPIClient({ timeout: 5000, retries: 3, network: 'livenet' }); Notes : - Accessing the SimplifiedMasternodeListDAPIAddressProvider (or its overwrote instance), can be accessed via client.dapiAddressProvider .","title":"DAPIClient"},{"location":"DAPI-Client/usage/application/getDataContract/","text":"Usage : async client.platform.getDataContract(contractId) Description : Fetch Data Contract by id Parameters: parameters type required Description contractId String yes A valid registered contractId Returns : Promise","title":"getDataContract"},{"location":"DAPI-Client/usage/application/getDocuments/","text":"Usage : async client.platform.getDocuments(contractId, type, options) Description : Fetch Documents from Drive Parameters: parameters type required Description contractId String yes A valid registered contractId type String yes DAP object type to fetch (e.g: 'preorder' in DPNS) options.where Object yes Mongo-like query options.orderBy Object yes Mongo-like sort field options.limit Number yes Limit the number of object to fetch options.startAt Number yes number of objects to skip options.startAfter Number yes exclusive skip Returns : Promise","title":"getDocuments"},{"location":"DAPI-Client/usage/application/getIdentity/","text":"Usage : async client.platform.getIdentity(id) Description : Fetch the identity by id Parameters: parameters type required Description id String yes A valid registered identity Returns : Promise<!Buffer|null>","title":"getIdentity"},{"location":"DAPI-Client/usage/application/getIdentityByFirstPublicKey/","text":"Usage : async client.platform.getIdentityByFirstPublicKey(publicKeyHash) Description : Fetch the identity using the public key hash of the identity's first key Parameters: parameters type required Description publicKeyHash String yes A valid public key hash Returns : Promise<!Buffer|null>","title":"getIdentityByFirstPublicKey"},{"location":"DAPI-Client/usage/application/getIdentityIdByFirstPublicKey/","text":"Usage : async client.platform.getIdentityIdByFirstPublicKey(publicKeyHash) Description : Fetch the identity ID using the public key hash of the identity's first key Parameters: parameters type required Description publicKeyHash String yes A valid public key hash Returns : Promise<!Buffer|null>","title":"getIdentityIdByFirstPublicKey"},{"location":"DAPI-Client/usage/application/core/broadcastTransaction/","text":"Usage : await client.core.broadcastTransaction(transaction) Description : Allow to broadcast a valid signed transaction to the network. Parameters: parameters type required Description transaction Buffer yes A valid Buffer representation of a transaction options Object options.allowHighFees Boolean no[=false] As safety measure, \"absurd\" fees are rejected when considered to high. This allow to overwrite that comportement options.bypassLimits Boolean no[=false] Allow to bypass default transaction policy rules limitation Returns : transactionId (string). N.B : The TransactionID provided is subject to transaction malleability , and is not a source of truth (the transaction might be included in a block with a different txid).","title":"broadcastTransaction"},{"location":"DAPI-Client/usage/application/core/generateToAddress/","text":"Usage : await client.core.generateToAddress(blockMumber, address, options) Description : Allow to broadcast a valid signed transaction to the network. Notes : Will only works on regtest. Parameters: parameters type required Description blocksNumber Number yes A number of block to see generated on the regtest network address String yes The address that will receive the newly generated Dash options DAPIClientOptions no Returns : {Promise } - a set of generated blockhashes.","title":"generateToAddress"},{"location":"DAPI-Client/usage/application/core/getBestBlockHash/","text":"Usage : await client.core.getBestBlockHash(options) Description : Allow to fetch the best (highest/latest block hash) from the network Parameters: parameters type required Description options DAPIClientOptions no Returns : {Promise } - The best block hash","title":"getBestBlockHash"},{"location":"DAPI-Client/usage/application/core/getBlockByHash/","text":"Usage : await client.core.getBlockByHash(hash, options) Description : Allow to fetch a specific block by its hash Parameters: parameters type required Description hash String yes A valid block hash options DAPIClientOptions no Returns : {Promise } - The specified bufferized block","title":"getBlockByHash"},{"location":"DAPI-Client/usage/application/core/getBlockByHeight/","text":"Usage : await client.core.getBlockByHeight(height, options) Description : Allow to fetch a specific block by its height Parameters: parameters type required Description height Number yes A valid block height options DAPIClientOptions no Returns : {Promise } - The specified bufferized block","title":"getBlockByHeight"},{"location":"DAPI-Client/usage/application/core/getBlockHash/","text":"Usage : await client.core.getBlockHash(height, options) Description : Allow to fetch a specific block hash from its height Parameters: parameters type required Description height Number yes A valid block height options DAPIClientOptions no Returns : {Promise } - the corresponding block hash","title":"getBlockHash"},{"location":"DAPI-Client/usage/application/core/getMnListDiff/","text":"Usage : await client.core.getMnListDiff(baseBlockHash, blockHash, options) Description : Allow to fetch a specific block hash from its height Parameters: parameters type required Description baseBlockHash String yes hash or height of start block blockHash String yes hash or height of end block options DAPIClientOptions no Returns : {Promise } - The Masternode List Diff of the specified period","title":"getMnListDiff"},{"location":"DAPI-Client/usage/application/core/getStatus/","text":"Usage : await client.core.getStatus(options) Description : Allow to fetch a specific block hash from its height Parameters: parameters type required Description options DAPIClientOptions no Returns : {Promise } - Status object const status = await client.core.getStatus() /** { coreVersion: 150000, protocolVersion: 70216, blocks: 10630, timeOffset: 0, connections: 58, proxy: '', difficulty: 0.001745769130443678, testnet: false, relayFee: 0.00001, errors: '', network: 'testnet' } **/","title":"getStatus"},{"location":"DAPI-Client/usage/application/core/getTransaction/","text":"Usage : await client.core.getTransaction(id, options) Description : Allow to fetch a transaction by ID Parameters: parameters type required Description id string yes A valid transaction id to fetch options DAPIClientOptions no Returns : {Promise } - The bufferized transaction","title":"getTransaction"},{"location":"DAPI-Client/usage/application/platform/broadcastStateTransition/","text":"Usage : async client.platform.broadcastStateTransition(stateTransition, options) Description : Send State Transition to machine Parameters: parameters type required Description stateTransition Buffer yes A valid bufferized state transition options DAPIClientOptions no A valid state transition Returns : Promise<!BroadcastStateTransitionResponse>","title":"broadcastStateTransition"},{"location":"DAPI-Client/usage/utils/subscribeToTransactionsWithProofs/","text":"Usage : await client.core.subscribeToTransactionsWithProofs(bloomFilter, options = { count: 0 }) \\ Description : For any provided bloomfilter, it will return a ClientReadableStream streaming the transaction matching the filter. Parameters: parameters type required Description bloomFilter.vData Uint8Array/Array yes The filter itself is simply a bit field of arbitrary byte-aligned size. The maximum size is 36,000 bytes. bloomFilter.nHashFuncs Number yes The number of hash functions to use in this filter. The maximum value allowed in this field is 50. bloomFilter.nTweak Number yes A random value to add to the seed value in the hash function used by the bloom filter. bloomFilter.nFlags Number yes A set of flags that control how matched items are added to the filter. options.fromBlockHash String yes Specifies block hash to start syncing from options.fromBlockHeight Number yes Specifies block height to start syncing from options.count Number no (default: 0) Number of blocks to sync, if set to 0 syncing is continuously sends new data as well Returns : Promise |!grpc.web.ClientReadableStream<!TransactionsWithProofsResponse> Example : const filter; // A BloomFilter object const stream = await client.subscribeToTransactionsWithProofs(filter, { fromBlockHeight: 0 }); stream .on('data', (response) => { const merkleBlock = response.getRawMerkleBlock(); const transactions = response.getRawTransactions(); if (merkleBlock) { const merkleBlockHex = Buffer.from(merkleBlock).toString('hex'); } if (transactions) { transactions.getTransactionsList() .forEach((tx) => { // tx are probabilistic, so you will have to verify it's yours const tx = new Transaction(Buffer.from(tx)); }); } }) .on('error', (err) => { // do something with err });","title":"subscribeToTransactionsWithProofs"},{"location":"Dash-Platform-Protocol/Overview/","text":"Usage new DashPlatformProtocol() dpp.dataContract dpp.document dpp.identity dpp.stateTransition Primitives AbstractStateTransition DataContract DataTrigger Document Identifier Identity License","title":"Overview"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/","text":"Usage : new AbstractStateTransition(rawStateTransition) Description : Instantiate a new AbstractStateTransition. Parameters : parameters type required Description rawStateTransition RawStateTransition yes rawStateTransition.protocolVersion number yes rawStateTransition.type number yes rawStateTransition.signature string/null yes Returns : A new valid instance of AbstractStateTransition .getProtocolVersion() Description : Get protocol version Parameters : None. Returns : {number} .getSignature() Description : Returns signature Parameters : None. Returns : {Buffer} .setSignature(signature) Description : Set signature Parameters : parameters type required Description signature Buffer no Returns : {AbstractStateTransition} .getId() Description : Get State Transition id Parameters : None. Returns : {Buffer} .signByPrivateKey(privateKey) Description : Sign data with private key Parameters : parameters type required Description signature string/Buffer/Uint8Array/PrivateKey no privateKey string must be hex or base58 Returns : {AbstractStateTransition} .verifySignatureByPublicKey(privateKey) Description : Verify signature with private key Parameters : parameters type required Description signature string/Buffer/Uint8Array/PrivateKey no privateKey string must be hex or base58 Returns : {boolean} .calculateFee() Description : Calculate ST fee in credits Parameters : None. Returns : {number} .toObject(options) Description : Return state transition as plain object Parameters : parameters type required Description options Object no options.skipSignature Boolean[=false] no options.skipIdentifiersConversion Boolean[=false] no Returns : {RawStateTransition} .toJSON() Description : Return state transition as JSON object Parameters : None. Returns : {JsonStateTransition} .toBuffer(options) Description : Return serialized State Transition as buffer Parameters : parameters type required Description options Object no options.skipSignature Boolean[=false] no Returns : {Buffer} .hash() Description : Returns state transition hash Parameters : None. Returns : {Buffer}","title":"AbstractStateTransition"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#getprotocolversion","text":"Description : Get protocol version Parameters : None. Returns : {number}","title":".getProtocolVersion()"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#getsignature","text":"Description : Returns signature Parameters : None. Returns : {Buffer}","title":".getSignature()"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#setsignaturesignature","text":"Description : Set signature Parameters : parameters type required Description signature Buffer no Returns : {AbstractStateTransition}","title":".setSignature(signature)"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#getid","text":"Description : Get State Transition id Parameters : None. Returns : {Buffer}","title":".getId()"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#signbyprivatekeyprivatekey","text":"Description : Sign data with private key Parameters : parameters type required Description signature string/Buffer/Uint8Array/PrivateKey no privateKey string must be hex or base58 Returns : {AbstractStateTransition}","title":".signByPrivateKey(privateKey)"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#verifysignaturebypublickeyprivatekey","text":"Description : Verify signature with private key Parameters : parameters type required Description signature string/Buffer/Uint8Array/PrivateKey no privateKey string must be hex or base58 Returns : {boolean}","title":".verifySignatureByPublicKey(privateKey)"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#calculatefee","text":"Description : Calculate ST fee in credits Parameters : None. Returns : {number}","title":".calculateFee()"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#toobjectoptions","text":"Description : Return state transition as plain object Parameters : parameters type required Description options Object no options.skipSignature Boolean[=false] no options.skipIdentifiersConversion Boolean[=false] no Returns : {RawStateTransition}","title":".toObject(options)"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#tojson","text":"Description : Return state transition as JSON object Parameters : None. Returns : {JsonStateTransition}","title":".toJSON()"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#tobufferoptions","text":"Description : Return serialized State Transition as buffer Parameters : parameters type required Description options Object no options.skipSignature Boolean[=false] no Returns : {Buffer}","title":".toBuffer(options)"},{"location":"Dash-Platform-Protocol/primitives/AbstractStateTransition/#hash","text":"Description : Returns state transition hash Parameters : None. Returns : {Buffer}","title":".hash()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/","text":"Usage : new DataContract(rawDataContract) Description : Instantiate a DataContract. Parameters : parameters type required Description rawDataContract RawDataContract yes rawDataContract.$id Buffer yes rawDataContract.$schema string yes rawDataContract.protocolVersion number yes rawDataContract.ownerId Buffer yes rawDataContract.documents Object yes rawDataContract.$defs Object no Returns : A new valid instance of DataContract .getProtocolVersion() Description : Get Data Contract protocol version Parameters : None. Returns : {number} .getId() Description : Get Data Contract id Parameters : None. Returns : {Identifier} .getOwnerId() Description : Get Data Contract owner id Parameters : None. Returns : {Identifier} .getJsonSchemaId() Description : Get Data Contract JSON Schema ID Parameters : None. Returns : {string} .getJsonMetaSchema() Description : Get Data Contract JSON Meta Schema Parameters : None. Returns : {string} .setJsonMetaSchema(schema) Description : Allow to set JSON Meta Schema to this DataContract (overwrite previous value). Parameters : parameters type required Description schema string yes Returns : {DataContract} .setDocuments(documents) Description : Set documents for this DataContract (overwrite previous value). Parameters : parameters type required Description documents Object yes Returns : {DataContract} .getDocuments() Description : Get Data Contract documents Parameters : None. Returns : {Object } - documents .isDocumentDefined(type) Description : Returns true if document type has been defined Parameters : parameters type required Description type string yes Returns : {Boolean} - whether document type has been defined .setDocumentSchema(type, schema) Description : Setter for document schema. Parameters : parameters type required Description type string yes schema object yes Returns : {DataContract} .getDocumentSchema(type) Description : Get Data Contract Document Schema for the provided type Parameters : parameters type required Description type string yes Returns : {Object} - document .getDocumentSchemaRef(type) Description : Get Data Contract Document schema reference Parameters : parameters type required Description type string yes Returns : {{$ref: string}} - reference .setDefinitions($defs) Description : Setter for $defs. Parameters : parameters type required Description $defs Object yes Returns : {DataContract} .getDefinitions() Description : Get Data Contract $defs Parameters : None. Returns : {Object } - $defs .getBinaryProperties(type) Description : Get properties with contentEncoding constraint Parameters : parameters type required Description type string yes Returns : {Object} .toObject(options) Description : Return Data Contract as plain object Parameters : parameters type required Description options Object no options.skipIdentifiersConversion Boolean no Returns : {RawDataContract} .toJSON() Description : Return Data Contract as JSON object Parameters : None. Returns : {JsonDataContract} .toBuffer() Description : Return Data Contract as a Buffer Parameters : None. Returns : {Buffer} .hash() Description : Returns Data Contract hash Parameters : None. Returns : {Buffer} .setEntropy(entropy) Description : Set Data Contract entropy Parameters : parameters type required Description entropy Buffer yes Returns : {DataContract} .getEntropy() Description : Get Data Contract entropy Parameters : None. Returns : {Buffer}","title":"DataContract"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getprotocolversion","text":"Description : Get Data Contract protocol version Parameters : None. Returns : {number}","title":".getProtocolVersion()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getid","text":"Description : Get Data Contract id Parameters : None. Returns : {Identifier}","title":".getId()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getownerid","text":"Description : Get Data Contract owner id Parameters : None. Returns : {Identifier}","title":".getOwnerId()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getjsonschemaid","text":"Description : Get Data Contract JSON Schema ID Parameters : None. Returns : {string}","title":".getJsonSchemaId()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getjsonmetaschema","text":"Description : Get Data Contract JSON Meta Schema Parameters : None. Returns : {string}","title":".getJsonMetaSchema()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#setjsonmetaschemaschema","text":"Description : Allow to set JSON Meta Schema to this DataContract (overwrite previous value). Parameters : parameters type required Description schema string yes Returns : {DataContract}","title":".setJsonMetaSchema(schema)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#setdocumentsdocuments","text":"Description : Set documents for this DataContract (overwrite previous value). Parameters : parameters type required Description documents Object yes Returns : {DataContract}","title":".setDocuments(documents)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getdocuments","text":"Description : Get Data Contract documents Parameters : None. Returns : {Object } - documents","title":".getDocuments()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#isdocumentdefinedtype","text":"Description : Returns true if document type has been defined Parameters : parameters type required Description type string yes Returns : {Boolean} - whether document type has been defined","title":".isDocumentDefined(type)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#setdocumentschematype-schema","text":"Description : Setter for document schema. Parameters : parameters type required Description type string yes schema object yes Returns : {DataContract}","title":".setDocumentSchema(type, schema)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getdocumentschematype","text":"Description : Get Data Contract Document Schema for the provided type Parameters : parameters type required Description type string yes Returns : {Object} - document","title":".getDocumentSchema(type)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getdocumentschemareftype","text":"Description : Get Data Contract Document schema reference Parameters : parameters type required Description type string yes Returns : {{$ref: string}} - reference","title":".getDocumentSchemaRef(type)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#setdefinitionsdefs","text":"Description : Setter for $defs. Parameters : parameters type required Description $defs Object yes Returns : {DataContract}","title":".setDefinitions($defs)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getdefinitions","text":"Description : Get Data Contract $defs Parameters : None. Returns : {Object } - $defs","title":".getDefinitions()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getbinarypropertiestype","text":"Description : Get properties with contentEncoding constraint Parameters : parameters type required Description type string yes Returns : {Object}","title":".getBinaryProperties(type)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#toobjectoptions","text":"Description : Return Data Contract as plain object Parameters : parameters type required Description options Object no options.skipIdentifiersConversion Boolean no Returns : {RawDataContract}","title":".toObject(options)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#tojson","text":"Description : Return Data Contract as JSON object Parameters : None. Returns : {JsonDataContract}","title":".toJSON()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#tobuffer","text":"Description : Return Data Contract as a Buffer Parameters : None. Returns : {Buffer}","title":".toBuffer()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#hash","text":"Description : Returns Data Contract hash Parameters : None. Returns : {Buffer}","title":".hash()"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#setentropyentropy","text":"Description : Set Data Contract entropy Parameters : parameters type required Description entropy Buffer yes Returns : {DataContract}","title":".setEntropy(entropy)"},{"location":"Dash-Platform-Protocol/primitives/DataContract/#getentropy","text":"Description : Get Data Contract entropy Parameters : None. Returns : {Buffer}","title":".getEntropy()"},{"location":"Dash-Platform-Protocol/primitives/DataTrigger/","text":"Usage : new DataTrigger(dataContractId, documentType, transitionAction, trigger, topLevelIdentity) Description : Instantiate a DataTrigger. Parameters : parameters type required Description dataContractId Buffer/Identifier yes documentType string yes transitionAction number yes trigger string/DocumentTransition[] yes topLevelIdentity Buffer/Identifier yes Returns : A new valid instance of DataTrigger .isMatchingTriggerForData(dataContractId, documentType, transitionAction) Description : Check this trigger is matching for specified data Parameters : parameters type required Description dataContractId string yes documentType string yes transitionAction number yes Returns : {boolean} .execute(documentTransition, context) Description : Execute data trigger Parameters : parameters type required Description documentTransition DocumentTransition[] yes context DataTriggerExecutionContext yes Returns : {Promise }}","title":"DataTrigger"},{"location":"Dash-Platform-Protocol/primitives/DataTrigger/#ismatchingtriggerfordatadatacontractid-documenttype-transitionaction","text":"Description : Check this trigger is matching for specified data Parameters : parameters type required Description dataContractId string yes documentType string yes transitionAction number yes Returns : {boolean}","title":".isMatchingTriggerForData(dataContractId, documentType, transitionAction)"},{"location":"Dash-Platform-Protocol/primitives/DataTrigger/#executedocumenttransition-context","text":"Description : Execute data trigger Parameters : parameters type required Description documentTransition DocumentTransition[] yes context DataTriggerExecutionContext yes Returns : {Promise }}","title":".execute(documentTransition, context)"},{"location":"Dash-Platform-Protocol/primitives/Document/","text":"Usage : new Document(rawDocument) Description : Instantiate a Document. Parameters : parameters type required Description rawDocument RawDocument yes rawDocument.$id Buffer yes rawDocument.$dataContractId string yes rawDocument.$protocolVersion number yes rawDocument.$type string yes rawDocument.$ownerId Buffer yes rawDocument.$revision number yes rawDocument.$createdAt number no rawDocument.$updatedAt number no dataContract DataContract yes Returns : A new valid instance of Document Document.fromJSON(jsonDocument, dataContract) Description : Instantiate a Document. Parameters : parameters type required Description jsonDocument JsonDocument yes dataContract DataContract yes Returns : {Document} - A new valid instance of Document .getProtocolVersion() Description : Get Document protocol version Parameters : None. Returns : {number} .getId() Description : Get Document id Parameters : None. Returns : {Identifier} .getType() Description : Get Document type Parameters : None. Returns : {string} .getDataContractId() Description : Get Document Contract Id Parameters : None. Returns : {Identifier} .getDataContract() Description : Get Document Data Contract Parameters : None. Returns : {DataContract} .getOwnerId() Description : Get Document owner id Parameters : None. Returns : {Identifier} .setRevision(revision) Description : Set Document revision Parameters : parameters type required Description revision number yes Returns : {Document} .getRevision() Description : Get Document revision Parameters : None. Returns : {number} .setEntropy(entropy) Description : Set Document entropy Parameters : parameters type required Description entropy Buffer yes Returns : {Document} .getEntropy() Description : Get Document entropy Parameters : None. Returns : {Buffer} .setData(data) Description : Set document data (overwrite any previous data set) Parameters : parameters type required Description data Object yes Returns : {Document} .getData() Description : Get Document data Parameters : None. Returns : {Object} .get(path) Description : Retrieves the field specified by path Parameters : parameters type required Description path String yes Returns : {*} .set(path, value) Description : Set the field specified by {path} Parameters : parameters type required Description path String yes value * yes Returns : {Document} .setCreatedAt(date) Description : Set document creation date Parameters : parameters type required Description date Date yes Returns : {Document} .getCreatedAt() Description : Get document creation date Parameters : None. Returns : {Date} .setUpdatedAt(date) Description : Set document updated date Parameters : parameters type required Description date Date yes Returns : {Document} .getUpdatedAt() Description : Get document updated date Parameters : None. Returns : {Date} .toJSON() Description : Return Document as JSON object Parameters : None. Returns : {JsonDocument} .toObject(options) Description : Return Document as plain object (without converting encoded fields) Parameters : parameters type required Description options Object no options.skipIdentifiersConversion boolean[=false] no Returns : {RawDocument} .toBuffer() Description : Return serialized Document as buffer Parameters : None. Returns : {Buffer} .hash() Description : Returns Document hash Parameters : None. Returns : {Buffer}","title":"Document"},{"location":"Dash-Platform-Protocol/primitives/Document/#documentfromjsonjsondocument-datacontract","text":"Description : Instantiate a Document. Parameters : parameters type required Description jsonDocument JsonDocument yes dataContract DataContract yes Returns : {Document} - A new valid instance of Document","title":"Document.fromJSON(jsonDocument, dataContract)"},{"location":"Dash-Platform-Protocol/primitives/Document/#getprotocolversion","text":"Description : Get Document protocol version Parameters : None. Returns : {number}","title":".getProtocolVersion()"},{"location":"Dash-Platform-Protocol/primitives/Document/#getid","text":"Description : Get Document id Parameters : None. Returns : {Identifier}","title":".getId()"},{"location":"Dash-Platform-Protocol/primitives/Document/#gettype","text":"Description : Get Document type Parameters : None. Returns : {string}","title":".getType()"},{"location":"Dash-Platform-Protocol/primitives/Document/#getdatacontractid","text":"Description : Get Document Contract Id Parameters : None. Returns : {Identifier}","title":".getDataContractId()"},{"location":"Dash-Platform-Protocol/primitives/Document/#getdatacontract","text":"Description : Get Document Data Contract Parameters : None. Returns : {DataContract}","title":".getDataContract()"},{"location":"Dash-Platform-Protocol/primitives/Document/#getownerid","text":"Description : Get Document owner id Parameters : None. Returns : {Identifier}","title":".getOwnerId()"},{"location":"Dash-Platform-Protocol/primitives/Document/#setrevisionrevision","text":"Description : Set Document revision Parameters : parameters type required Description revision number yes Returns : {Document}","title":".setRevision(revision)"},{"location":"Dash-Platform-Protocol/primitives/Document/#getrevision","text":"Description : Get Document revision Parameters : None. Returns : {number}","title":".getRevision()"},{"location":"Dash-Platform-Protocol/primitives/Document/#setentropyentropy","text":"Description : Set Document entropy Parameters : parameters type required Description entropy Buffer yes Returns : {Document}","title":".setEntropy(entropy)"},{"location":"Dash-Platform-Protocol/primitives/Document/#getentropy","text":"Description : Get Document entropy Parameters : None. Returns : {Buffer}","title":".getEntropy()"},{"location":"Dash-Platform-Protocol/primitives/Document/#setdatadata","text":"Description : Set document data (overwrite any previous data set) Parameters : parameters type required Description data Object yes Returns : {Document}","title":".setData(data)"},{"location":"Dash-Platform-Protocol/primitives/Document/#getdata","text":"Description : Get Document data Parameters : None. Returns : {Object}","title":".getData()"},{"location":"Dash-Platform-Protocol/primitives/Document/#getpath","text":"Description : Retrieves the field specified by path Parameters : parameters type required Description path String yes Returns : {*}","title":".get(path)"},{"location":"Dash-Platform-Protocol/primitives/Document/#setpath-value","text":"Description : Set the field specified by {path} Parameters : parameters type required Description path String yes value * yes Returns : {Document}","title":".set(path, value)"},{"location":"Dash-Platform-Protocol/primitives/Document/#setcreatedatdate","text":"Description : Set document creation date Parameters : parameters type required Description date Date yes Returns : {Document}","title":".setCreatedAt(date)"},{"location":"Dash-Platform-Protocol/primitives/Document/#getcreatedat","text":"Description : Get document creation date Parameters : None. Returns : {Date}","title":".getCreatedAt()"},{"location":"Dash-Platform-Protocol/primitives/Document/#setupdatedatdate","text":"Description : Set document updated date Parameters : parameters type required Description date Date yes Returns : {Document}","title":".setUpdatedAt(date)"},{"location":"Dash-Platform-Protocol/primitives/Document/#getupdatedat","text":"Description : Get document updated date Parameters : None. Returns : {Date}","title":".getUpdatedAt()"},{"location":"Dash-Platform-Protocol/primitives/Document/#tojson","text":"Description : Return Document as JSON object Parameters : None. Returns : {JsonDocument}","title":".toJSON()"},{"location":"Dash-Platform-Protocol/primitives/Document/#toobjectoptions","text":"Description : Return Document as plain object (without converting encoded fields) Parameters : parameters type required Description options Object no options.skipIdentifiersConversion boolean[=false] no Returns : {RawDocument}","title":".toObject(options)"},{"location":"Dash-Platform-Protocol/primitives/Document/#tobuffer","text":"Description : Return serialized Document as buffer Parameters : None. Returns : {Buffer}","title":".toBuffer()"},{"location":"Dash-Platform-Protocol/primitives/Document/#hash","text":"Description : Returns Document hash Parameters : None. Returns : {Buffer}","title":".hash()"},{"location":"Dash-Platform-Protocol/primitives/Identifier/","text":"Usage : new Identifier(buffer) Description : Instantiate a new Identifier. Implements Buffer methods with base58 as default encoding. Parameters : parameters type required Description buffer Buffer yes Returns : A new valid instance of Identifier .encodeCBOR(encoder) Description : Encode to CBOR Parameters : parameters type required Description encoder Encoder yes Returns : {boolean} .toJSON() Description : Return Identity as JSON object Parameters : None. Returns : {RawIdentity} .toBuffer() Description : Convert to Buffer Parameters : None. Returns : {Buffer}","title":"Identifier"},{"location":"Dash-Platform-Protocol/primitives/Identifier/#encodecborencoder","text":"Description : Encode to CBOR Parameters : parameters type required Description encoder Encoder yes Returns : {boolean}","title":".encodeCBOR(encoder)"},{"location":"Dash-Platform-Protocol/primitives/Identifier/#tojson","text":"Description : Return Identity as JSON object Parameters : None. Returns : {RawIdentity}","title":".toJSON()"},{"location":"Dash-Platform-Protocol/primitives/Identifier/#tobuffer","text":"Description : Convert to Buffer Parameters : None. Returns : {Buffer}","title":".toBuffer()"},{"location":"Dash-Platform-Protocol/primitives/Identity/","text":"Usage : new Identity(rawIdentity) Description : Instantiate a new Identity. Parameters : parameters type required Description rawIdentity RawIdentity yes rawIdentity.id Buffer yes rawIdentity.protocolVersion number yes rawIdentity.publicKeys RawIdentityPublicKey[] yes rawIdentity.balance number yes rawIdentity.revision number yes Returns : A new valid instance of Identity .getProtocolVersion() Description : Get Identity protocol version Parameters : None. Returns : {number} .getId() Description : Get Identity id Parameters : None. Returns : {Identifier} .setPublicKeys(publicKeys) Description : Set Identity public keys Parameters : parameters type required Description publicKeys RawIdentityPublicKey[] yes Returns : {Identity} .getPublicKeys() Description : Get Identity public keys revision Parameters : None. Returns : {IdentityPublicKey[]} .getPublicKeyById(keyId) Description : Returns a public key for a given id Parameters : parameters type required Description keyId number yes Returns : {IdentityPublicKey} .getBalance() Description : Returns balance Parameters : None. Returns : {number} .setBalance(balance) Description : Set Identity balance Parameters : parameters type required Description balance number yes Returns : {Identity} .increaseBalance(amount) Description : Increase Identity balance Parameters : parameters type required Description amount number yes Returns : {Identity} .reduceBalance(amount) Description : Reduce Identity balance Parameters : parameters type required Description amount number yes Returns : {Identity} .setAssetLock(assetLock) Description : Set Identity asset lock Parameters : parameters type required Description assetLock AssetLock yes Returns : {Identity} .getAssetLock() Description : Returns Identity asset lock Parameters : None. Returns : {AssetLock} .setRevision(revision) Description : Set Identity revision Parameters : parameters type required Description revision number yes Returns : {Identity} .getRevision() Description : Get Identity revision Parameters : None. Returns : {number} .toObject() Description : Return Identity as plain object Parameters : None. Returns : {Object} .toJSON() Description : Return Identity as JSON object Parameters : None. Returns : {RawIdentity} .toBuffer() Description : Return Identity as Buffer Parameters : None. Returns : {Buffer} .hash() Description : Returns Identity hash Parameters : None. Returns : {Buffer}","title":"Identity"},{"location":"Dash-Platform-Protocol/primitives/Identity/#getprotocolversion","text":"Description : Get Identity protocol version Parameters : None. Returns : {number}","title":".getProtocolVersion()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#getid","text":"Description : Get Identity id Parameters : None. Returns : {Identifier}","title":".getId()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#setpublickeyspublickeys","text":"Description : Set Identity public keys Parameters : parameters type required Description publicKeys RawIdentityPublicKey[] yes Returns : {Identity}","title":".setPublicKeys(publicKeys)"},{"location":"Dash-Platform-Protocol/primitives/Identity/#getpublickeys","text":"Description : Get Identity public keys revision Parameters : None. Returns : {IdentityPublicKey[]}","title":".getPublicKeys()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#getpublickeybyidkeyid","text":"Description : Returns a public key for a given id Parameters : parameters type required Description keyId number yes Returns : {IdentityPublicKey}","title":".getPublicKeyById(keyId)"},{"location":"Dash-Platform-Protocol/primitives/Identity/#getbalance","text":"Description : Returns balance Parameters : None. Returns : {number}","title":".getBalance()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#setbalancebalance","text":"Description : Set Identity balance Parameters : parameters type required Description balance number yes Returns : {Identity}","title":".setBalance(balance)"},{"location":"Dash-Platform-Protocol/primitives/Identity/#increasebalanceamount","text":"Description : Increase Identity balance Parameters : parameters type required Description amount number yes Returns : {Identity}","title":".increaseBalance(amount)"},{"location":"Dash-Platform-Protocol/primitives/Identity/#reducebalanceamount","text":"Description : Reduce Identity balance Parameters : parameters type required Description amount number yes Returns : {Identity}","title":".reduceBalance(amount)"},{"location":"Dash-Platform-Protocol/primitives/Identity/#setassetlockassetlock","text":"Description : Set Identity asset lock Parameters : parameters type required Description assetLock AssetLock yes Returns : {Identity}","title":".setAssetLock(assetLock)"},{"location":"Dash-Platform-Protocol/primitives/Identity/#getassetlock","text":"Description : Returns Identity asset lock Parameters : None. Returns : {AssetLock}","title":".getAssetLock()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#setrevisionrevision","text":"Description : Set Identity revision Parameters : parameters type required Description revision number yes Returns : {Identity}","title":".setRevision(revision)"},{"location":"Dash-Platform-Protocol/primitives/Identity/#getrevision","text":"Description : Get Identity revision Parameters : None. Returns : {number}","title":".getRevision()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#toobject","text":"Description : Return Identity as plain object Parameters : None. Returns : {Object}","title":".toObject()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#tojson","text":"Description : Return Identity as JSON object Parameters : None. Returns : {RawIdentity}","title":".toJSON()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#tobuffer","text":"Description : Return Identity as Buffer Parameters : None. Returns : {Buffer}","title":".toBuffer()"},{"location":"Dash-Platform-Protocol/primitives/Identity/#hash","text":"Description : Returns Identity hash Parameters : None. Returns : {Buffer}","title":".hash()"},{"location":"Dash-Platform-Protocol/usage/DashPlatformProtocol/","text":"new DashPlatformProtocol(options) Description : Instantiate DashPlatformProtocol. Parameters : parameters type required Description options Object no options.stateRepository StateRepository no options.jsonSchemaValidator JsonSchemaValidator no Returns : {DashPlatformProtocol} Notes : DPP will provide multiples facades: dpp.dataContract dpp.document dpp.identity dpp.stateTransition .getJsonSchemaValidator() Description : Return JSON Schema Validator Parameters : None Returns : {JsonSchemaValidator} .getStateRepository() Description : Return State Repository Parameters : None Returns : {StateRepository}","title":"DashPlatformProtocol"},{"location":"Dash-Platform-Protocol/usage/DashPlatformProtocol/#new-dashplatformprotocoloptions","text":"Description : Instantiate DashPlatformProtocol. Parameters : parameters type required Description options Object no options.stateRepository StateRepository no options.jsonSchemaValidator JsonSchemaValidator no Returns : {DashPlatformProtocol} Notes : DPP will provide multiples facades: dpp.dataContract dpp.document dpp.identity dpp.stateTransition","title":"new DashPlatformProtocol(options)"},{"location":"Dash-Platform-Protocol/usage/DashPlatformProtocol/#getjsonschemavalidator","text":"Description : Return JSON Schema Validator Parameters : None Returns : {JsonSchemaValidator}","title":".getJsonSchemaValidator()"},{"location":"Dash-Platform-Protocol/usage/DashPlatformProtocol/#getstaterepository","text":"Description : Return State Repository Parameters : None Returns : {StateRepository}","title":".getStateRepository()"},{"location":"Dash-Platform-Protocol/usage/dataContract/","text":"dpp.dataContract.create(ownerId, documents) Description : Instantiate a new Data Contract. This method will generate the entropy and dataContractId for the user. Parameters : parameters type required Description ownerId Buffer yes documents Object yes Returns : { DataContract } dpp.dataContract.createFromObject(rawDataContract, options) Description : Instantiate a new Data Contract from plain object representation. By default, the provided rawDataContract will be validated. Parameters : parameters type required Description rawDataContract RawDataContract yes options Object no options.skipValidation boolean[=false] no Returns : {Promise< DataContract >} dpp.dataContract.createFromBuffer(buffer, options) Description : Instantiate a new Data Contract from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no Returns : {Promise< DataContract >} dpp.dataContract.createDataContractCreateTransition(dataContract) Description : Create a new Data Contract State Transition Parameters : parameters type required Description dataContract DataContract yes Returns : {DataContractCreateTransition} dpp.dataContract.validate(dataContract) Description : Validate Data Contract Parameters : parameters type required Description dataContract DataContract/RawDataContract yes Returns : {Promise }","title":"dataContract"},{"location":"Dash-Platform-Protocol/usage/dataContract/#dppdatacontractcreateownerid-documents","text":"Description : Instantiate a new Data Contract. This method will generate the entropy and dataContractId for the user. Parameters : parameters type required Description ownerId Buffer yes documents Object yes Returns : { DataContract }","title":"dpp.dataContract.create(ownerId, documents)"},{"location":"Dash-Platform-Protocol/usage/dataContract/#dppdatacontractcreatefromobjectrawdatacontract-options","text":"Description : Instantiate a new Data Contract from plain object representation. By default, the provided rawDataContract will be validated. Parameters : parameters type required Description rawDataContract RawDataContract yes options Object no options.skipValidation boolean[=false] no Returns : {Promise< DataContract >}","title":"dpp.dataContract.createFromObject(rawDataContract, options)"},{"location":"Dash-Platform-Protocol/usage/dataContract/#dppdatacontractcreatefrombufferbuffer-options","text":"Description : Instantiate a new Data Contract from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no Returns : {Promise< DataContract >}","title":"dpp.dataContract.createFromBuffer(buffer, options)"},{"location":"Dash-Platform-Protocol/usage/dataContract/#dppdatacontractcreatedatacontractcreatetransitiondatacontract","text":"Description : Create a new Data Contract State Transition Parameters : parameters type required Description dataContract DataContract yes Returns : {DataContractCreateTransition}","title":"dpp.dataContract.createDataContractCreateTransition(dataContract)"},{"location":"Dash-Platform-Protocol/usage/dataContract/#dppdatacontractvalidatedatacontract","text":"Description : Validate Data Contract Parameters : parameters type required Description dataContract DataContract/RawDataContract yes Returns : {Promise }","title":"dpp.dataContract.validate(dataContract)"},{"location":"Dash-Platform-Protocol/usage/document/","text":"dpp.document.create(dataContract, ownerId, type, data = {}) Description : Instantiate a new Document for a specific contract, owner, type. This method will populate it with specified data and validate upon creation. Parameters : parameters type required Description dataContract DataContract yes ownerId Buffer yes type string yes data Object[={}] no Returns : { Document } dpp.document.createFromObject(rawDocument, options) Description : Instantiate a new Document from plain object representation. By default, the provided Document will be validated. Parameters : parameters type required Description rawDocument RawDocument yes options Object no options.skipValidation boolean[=false] no options.action boolean no Returns : {Promise< Document >} dpp.document.createFromBuffer(buffer, options) Description : Instantiate a new Document from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no options.action boolean no Returns : {Promise< Document >} dpp.document.createStateTransition(documents) Description : Create Documents State Transition Parameters : parameters type required Description documents Object yes documents.create Document[] no documents.replace Document[] no documents.delete Document[] no Returns : {DocumentsBatchTransition} dpp.document.validate(document) Description : Validate document Parameters : parameters type required Description document Document/RawDocument yes Returns : {Promise }","title":"Document"},{"location":"Dash-Platform-Protocol/usage/document/#dppdocumentcreatedatacontract-ownerid-type-data","text":"Description : Instantiate a new Document for a specific contract, owner, type. This method will populate it with specified data and validate upon creation. Parameters : parameters type required Description dataContract DataContract yes ownerId Buffer yes type string yes data Object[={}] no Returns : { Document }","title":"dpp.document.create(dataContract, ownerId, type, data = {})"},{"location":"Dash-Platform-Protocol/usage/document/#dppdocumentcreatefromobjectrawdocument-options","text":"Description : Instantiate a new Document from plain object representation. By default, the provided Document will be validated. Parameters : parameters type required Description rawDocument RawDocument yes options Object no options.skipValidation boolean[=false] no options.action boolean no Returns : {Promise< Document >}","title":"dpp.document.createFromObject(rawDocument, options)"},{"location":"Dash-Platform-Protocol/usage/document/#dppdocumentcreatefrombufferbuffer-options","text":"Description : Instantiate a new Document from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no options.action boolean no Returns : {Promise< Document >}","title":"dpp.document.createFromBuffer(buffer, options)"},{"location":"Dash-Platform-Protocol/usage/document/#dppdocumentcreatestatetransitiondocuments","text":"Description : Create Documents State Transition Parameters : parameters type required Description documents Object yes documents.create Document[] no documents.replace Document[] no documents.delete Document[] no Returns : {DocumentsBatchTransition}","title":"dpp.document.createStateTransition(documents)"},{"location":"Dash-Platform-Protocol/usage/document/#dppdocumentvalidatedocument","text":"Description : Validate document Parameters : parameters type required Description document Document/RawDocument yes Returns : {Promise }","title":"dpp.document.validate(document)"},{"location":"Dash-Platform-Protocol/usage/identity/","text":"dpp.identity.create(lockedOutPoint, publicKeys = []) Description : Instantiate a new Identity. Parameters : parameters type required Description assetLockTransaction Transaction yes outputIndex number yes assetLockProof InstantAssetLockProof yes publicKeys PublicKey[] yes Returns : { Identity } dpp.identity.createFromObject(rawIdentity, options) Description : Instantiate a new Identity from plain object representation. Parameters : parameters type required Description rawIdentity RawIdentity yes options Object no options.skipValidation boolean[=false] no Returns : { Identity } dpp.identity.createFromBuffer(buffer, options) Description : Instantiate a new Identity from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no Returns : { Identity } dpp.identity.validate(identity) Description : Validate Identity Parameters : parameters type required Description identity Identity/RawIdentity yes Returns : {ValidationResult} dpp.identity.createInstantAssetLockProof(instantLock) Description : Create a instant asset lock proof Identity. Parameters : parameters type required Description instantLock InstantLock yes Returns : {InstantAssetLookProof} dpp.identity.createIdentityCreateTransition(identity) Description : Create Identity Create Transition Parameters : parameters type required Description identity Identity yes Returns : {IdentityCreateTransition} dpp.identity.createIdentityTopUpTransition(identityId, lockedOutPoint) Description : Create Identity Create Transition Parameters : parameters type required Description identityId Identifier/Buffer/String yes identity id to top up lockedOutPoint Buffer yes outpoint of the top up output of the L1 transaction Returns : {IdentityTopUpTransition}","title":"Identity"},{"location":"Dash-Platform-Protocol/usage/identity/#dppidentitycreatelockedoutpoint-publickeys","text":"Description : Instantiate a new Identity. Parameters : parameters type required Description assetLockTransaction Transaction yes outputIndex number yes assetLockProof InstantAssetLockProof yes publicKeys PublicKey[] yes Returns : { Identity }","title":"dpp.identity.create(lockedOutPoint, publicKeys = [])"},{"location":"Dash-Platform-Protocol/usage/identity/#dppidentitycreatefromobjectrawidentity-options","text":"Description : Instantiate a new Identity from plain object representation. Parameters : parameters type required Description rawIdentity RawIdentity yes options Object no options.skipValidation boolean[=false] no Returns : { Identity }","title":"dpp.identity.createFromObject(rawIdentity, options)"},{"location":"Dash-Platform-Protocol/usage/identity/#dppidentitycreatefrombufferbuffer-options","text":"Description : Instantiate a new Identity from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no Returns : { Identity }","title":"dpp.identity.createFromBuffer(buffer, options)"},{"location":"Dash-Platform-Protocol/usage/identity/#dppidentityvalidateidentity","text":"Description : Validate Identity Parameters : parameters type required Description identity Identity/RawIdentity yes Returns : {ValidationResult}","title":"dpp.identity.validate(identity)"},{"location":"Dash-Platform-Protocol/usage/identity/#dppidentitycreateinstantassetlockproofinstantlock","text":"Description : Create a instant asset lock proof Identity. Parameters : parameters type required Description instantLock InstantLock yes Returns : {InstantAssetLookProof}","title":"dpp.identity.createInstantAssetLockProof(instantLock)"},{"location":"Dash-Platform-Protocol/usage/identity/#dppidentitycreateidentitycreatetransitionidentity","text":"Description : Create Identity Create Transition Parameters : parameters type required Description identity Identity yes Returns : {IdentityCreateTransition}","title":"dpp.identity.createIdentityCreateTransition(identity)"},{"location":"Dash-Platform-Protocol/usage/identity/#dppidentitycreateidentitytopuptransitionidentityid-lockedoutpoint","text":"Description : Create Identity Create Transition Parameters : parameters type required Description identityId Identifier/Buffer/String yes identity id to top up lockedOutPoint Buffer yes outpoint of the top up output of the L1 transaction Returns : {IdentityTopUpTransition}","title":"dpp.identity.createIdentityTopUpTransition(identityId, lockedOutPoint)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/","text":"dpp.stateTransition.createFromJSON(rawStateTransition, options) Description : Create State Transition from JSON. Parameters : parameters type required Description rawStateTransition RawDataContractCreateTransition/RawDocumentsBatchTransition yes options Object no options.skipValidation boolean[=false] no Returns : {RawDataContractCreateTransition|DocumentsBatchTransition} dpp.stateTransition.createFromObject(rawStateTransition, options) Description : Create State Transition from a plain object. Parameters : parameters type required Description rawStateTransition RawDataContractCreateTransition/RawDocumentsBatchTransition yes options Object no options.skipValidation boolean[=false] no Returns : {RawDataContractCreateTransition|DocumentsBatchTransition} dpp.stateTransition.createFromBuffer(buffer, options) Description : Create State Transition from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no Returns : {RawDataContractCreateTransition|DocumentsBatchTransition} dpp.stateTransition.validate(stateTransition) Description : Validate State Transition Parameters : parameters type required Description stateTransition RawStateTransition/AbstractStateTransition yes Returns : {ValidationResult} dpp.stateTransition.validateBasic(stateTransition) Description : Validate State Transition structure and data Parameters : parameters type required Description stateTransition AbstractStateTransition/RawStateTransition yes Returns : {ValidationResult} dpp.stateTransition.validateSignature(stateTransition) Description : Validate State Transition signature and ownership Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {ValidationResult} dpp.stateTransition.validateFee(stateTransition) Description : Validate State Transition fee Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {ValidationResult} dpp.stateTransition.validateState(stateTransition) Description : Validate State Transition against existing state Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {ValidationResult} dpp.stateTransition.apply(stateTransition) Description : Apply state transition to the state Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {Promise }","title":"stateTransition"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitioncreatefromjsonrawstatetransition-options","text":"Description : Create State Transition from JSON. Parameters : parameters type required Description rawStateTransition RawDataContractCreateTransition/RawDocumentsBatchTransition yes options Object no options.skipValidation boolean[=false] no Returns : {RawDataContractCreateTransition|DocumentsBatchTransition}","title":"dpp.stateTransition.createFromJSON(rawStateTransition, options)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitioncreatefromobjectrawstatetransition-options","text":"Description : Create State Transition from a plain object. Parameters : parameters type required Description rawStateTransition RawDataContractCreateTransition/RawDocumentsBatchTransition yes options Object no options.skipValidation boolean[=false] no Returns : {RawDataContractCreateTransition|DocumentsBatchTransition}","title":"dpp.stateTransition.createFromObject(rawStateTransition, options)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitioncreatefrombufferbuffer-options","text":"Description : Create State Transition from buffer. Parameters : parameters type required Description buffer Buffer yes options Object no options.skipValidation boolean[=false] no Returns : {RawDataContractCreateTransition|DocumentsBatchTransition}","title":"dpp.stateTransition.createFromBuffer(buffer, options)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitionvalidatestatetransition","text":"Description : Validate State Transition Parameters : parameters type required Description stateTransition RawStateTransition/AbstractStateTransition yes Returns : {ValidationResult}","title":"dpp.stateTransition.validate(stateTransition)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitionvalidatebasicstatetransition","text":"Description : Validate State Transition structure and data Parameters : parameters type required Description stateTransition AbstractStateTransition/RawStateTransition yes Returns : {ValidationResult}","title":"dpp.stateTransition.validateBasic(stateTransition)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitionvalidatesignaturestatetransition","text":"Description : Validate State Transition signature and ownership Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {ValidationResult}","title":"dpp.stateTransition.validateSignature(stateTransition)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitionvalidatefeestatetransition","text":"Description : Validate State Transition fee Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {ValidationResult}","title":"dpp.stateTransition.validateFee(stateTransition)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitionvalidatestatestatetransition","text":"Description : Validate State Transition against existing state Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {ValidationResult}","title":"dpp.stateTransition.validateState(stateTransition)"},{"location":"Dash-Platform-Protocol/usage/stateTransition/#dppstatetransitionapplystatetransition","text":"Description : Apply state transition to the state Parameters : parameters type required Description stateTransition AbstractStateTransition yes Returns : {Promise }","title":"dpp.stateTransition.apply(stateTransition)"},{"location":"SDK/","text":"Dash SDK Dash library for JavaScript/TypeScript ecosystem (Wallet, DAPI, Primitives, BLS, ...) Dash library provides access via DAPI to use both the Dash Core network and Dash Platform on supported networks . The Dash Core network can be used to broadcast and receive payments. Dash Platform can be used to manage identities, register data contracts for applications, and submit or retrieve application data via documents. Install From NPM In order to use this library, you will need to add our NPM package to your project. Having NodeJS installed, just type: npm install dash From unpkg <script src=\"https://unpkg.com/dash\"></script> Usage examples Generate a mnemonic Receive money and display balance Pay to another address Use another BIP44 account Dash Platform Tutorials See the Tutorial section of the Dash Platform documentation for examples. Licence MIT \u00a9 Dash Core Group, Inc.","title":"Dash SDK"},{"location":"SDK/#dash-sdk","text":"Dash library for JavaScript/TypeScript ecosystem (Wallet, DAPI, Primitives, BLS, ...) Dash library provides access via DAPI to use both the Dash Core network and Dash Platform on supported networks . The Dash Core network can be used to broadcast and receive payments. Dash Platform can be used to manage identities, register data contracts for applications, and submit or retrieve application data via documents.","title":"Dash SDK"},{"location":"SDK/#install","text":"","title":"Install"},{"location":"SDK/#from-npm","text":"In order to use this library, you will need to add our NPM package to your project. Having NodeJS installed, just type: npm install dash","title":"From NPM"},{"location":"SDK/#from-unpkg","text":"<script src=\"https://unpkg.com/dash\"></script>","title":"From unpkg"},{"location":"SDK/#usage-examples","text":"Generate a mnemonic Receive money and display balance Pay to another address Use another BIP44 account","title":"Usage examples"},{"location":"SDK/#dash-platform-tutorials","text":"See the Tutorial section of the Dash Platform documentation for examples.","title":"Dash Platform Tutorials"},{"location":"SDK/#licence","text":"MIT \u00a9 Dash Core Group, Inc.","title":"Licence"},{"location":"SDK/Overview/","text":"Getting started Quick start Quick introduction to core concepts Working with multiple apps Dash Platform Applications About Schemas Examples Generate a mnemonic Receive money and display balance Pay to another address Fetch an identity from its name Use another BIP44 account Sign and verify messages Usage DAPI Platform About platform Identities About identities .get() .register() .topUp() Contracts About contracts .get() .create() .publish() .update() Documents About documents .get() .create() .broadcast() Names About DPNS .register() .resolve() .resolveByRecord() .search() Wallet Accounts Signing, Encrypt and Decrypt Dashcore Primitives License","title":"Overview"},{"location":"SDK/examples/fetch-an-identity-from-its-name/","text":"Fetching an identity from its name Assuming you have created an identity and attached a name to it (see how to register an identity and how to attach it to a name ), you will then be able to directly recover an identity from its names. See below: const client = new Dash.Client({ wallet: { mnemonic: '', // Your app mnemonic, which holds the identity }, }); // This is the name previously registered in DPNS. const identityName = 'alice'; const nameDocument = await client.platform.names.resolve(`${identityName}.dash`); const identity = await client.platform.identities.get(nameDocument.ownerId);","title":"Fetch an identity from its name"},{"location":"SDK/examples/fetch-an-identity-from-its-name/#fetching-an-identity-from-its-name","text":"Assuming you have created an identity and attached a name to it (see how to register an identity and how to attach it to a name ), you will then be able to directly recover an identity from its names. See below: const client = new Dash.Client({ wallet: { mnemonic: '', // Your app mnemonic, which holds the identity }, }); // This is the name previously registered in DPNS. const identityName = 'alice'; const nameDocument = await client.platform.names.resolve(`${identityName}.dash`); const identity = await client.platform.identities.get(nameDocument.ownerId);","title":"Fetching an identity from its name"},{"location":"SDK/examples/generate-a-new-mnemonic/","text":"Generate a new mnemonic In order to be able to keep your private keys private, we encourage to create your own mnemonic instead of using those from the examples (that might be empty). Below, you will be proposed two options allowing you to create a new mnemonic, depending on the level of customisation you need. Dash.Client By passing null to the mnemonic value of the wallet options, you can get Wallet-lib to generate a new mnemonic for you. const Dash = require(\"dash\"); const client = new Dash.Client({ network: \"testnet\", wallet: { mnemonic: null, }, }); const mnemonic = client.wallet.exportWallet(); console.log({mnemonic}); Dash.Mnemonic const Dash = require(\"dash\"); const {Mnemonic} = Dash.Core; const mnemnonic = new Mnemonic().toString() Language selection const {Mnemonic} = Dash.Core; const {CHINESE, ENGLISH, FRENCH, ITALIAN, JAPANESE, SPANISH} = Mnemonic.Words; console.log(new Mnemonic(Mnemonic.Words.FRENCH).toString()) Entropy size By default, the value for mnemonic is 128 (12 words), but you can generate a 24 words (or other) : const {Mnemonic} = Dash.Core; console.log(new Mnemonic(256).toString()) You can even replace the word list by your own, providing a list of 2048 unique words.","title":"Generate a new mnemonic"},{"location":"SDK/examples/generate-a-new-mnemonic/#generate-a-new-mnemonic","text":"In order to be able to keep your private keys private, we encourage to create your own mnemonic instead of using those from the examples (that might be empty). Below, you will be proposed two options allowing you to create a new mnemonic, depending on the level of customisation you need.","title":"Generate a new mnemonic"},{"location":"SDK/examples/generate-a-new-mnemonic/#dashclient","text":"By passing null to the mnemonic value of the wallet options, you can get Wallet-lib to generate a new mnemonic for you. const Dash = require(\"dash\"); const client = new Dash.Client({ network: \"testnet\", wallet: { mnemonic: null, }, }); const mnemonic = client.wallet.exportWallet(); console.log({mnemonic});","title":"Dash.Client"},{"location":"SDK/examples/generate-a-new-mnemonic/#dashmnemonic","text":"const Dash = require(\"dash\"); const {Mnemonic} = Dash.Core; const mnemnonic = new Mnemonic().toString()","title":"Dash.Mnemonic"},{"location":"SDK/examples/generate-a-new-mnemonic/#language-selection","text":"const {Mnemonic} = Dash.Core; const {CHINESE, ENGLISH, FRENCH, ITALIAN, JAPANESE, SPANISH} = Mnemonic.Words; console.log(new Mnemonic(Mnemonic.Words.FRENCH).toString())","title":"Language selection"},{"location":"SDK/examples/generate-a-new-mnemonic/#entropy-size","text":"By default, the value for mnemonic is 128 (12 words), but you can generate a 24 words (or other) : const {Mnemonic} = Dash.Core; console.log(new Mnemonic(256).toString()) You can even replace the word list by your own, providing a list of 2048 unique words.","title":"Entropy size"},{"location":"SDK/examples/pay-to-another-address/","text":"Paying to another address In order to pay, you need to have an existing balance . The below code will allow you to pay to a single address a specific amount of satoshis. const Dash = require('dash'); const mnemonic = ''; // your mnemonic here. const client = new Dash.Client({ wallet: { mnemonic, }, }); async function payToRecipient(account) { const transaction = account.createTransaction({ recipient: 'yNPbcFfabtNmmxKdGwhHomdYfVs6gikbPf', satoshis: 10000, }); const transactionId = await account.broadcastTransaction(transaction); } client.wallet.getAccount().then(payToRecipient); See more on create transaction options here .","title":"Pay to another address"},{"location":"SDK/examples/pay-to-another-address/#paying-to-another-address","text":"In order to pay, you need to have an existing balance . The below code will allow you to pay to a single address a specific amount of satoshis. const Dash = require('dash'); const mnemonic = ''; // your mnemonic here. const client = new Dash.Client({ wallet: { mnemonic, }, }); async function payToRecipient(account) { const transaction = account.createTransaction({ recipient: 'yNPbcFfabtNmmxKdGwhHomdYfVs6gikbPf', satoshis: 10000, }); const transactionId = await account.broadcastTransaction(transaction); } client.wallet.getAccount().then(payToRecipient); See more on create transaction options here .","title":"Paying to another address"},{"location":"SDK/examples/receive-money-and-check-balance/","text":"Receive money and display balance Initialize the SDK Client with your generated mnemonic passed as an option. const Dash = require(\"dash\"); const mnemonic = ''// your mnemonic here. const client = new Dash.Client({ wallet: { mnemonic, } }); async function showBalance() { const account = await client.wallet.getAccount(); const totalBalance = account.getTotalBalance(); console.log(`Account's total balance: ${totalBalance} duffs`); } Having your client instance set up, you will be able to access the account and wallet instance generated from your mnemonic. By default getAccount() returns the first BIP44 account. You can read more on how to use a different account . Generate a receiving address Dash wallet supports two different types of addresses: - external addresses used for receiving funds from other addresses - internal addresses used for change outputs of outgoing transactions - For your privacy, you might want to generate a new address for each payment: async function generateUnusedAddress() { const account = await client.wallet.getAccount(); const { address } = account.getUnusedAddress(); console.log(`Unused external address: ${address}`); } This above code will generate a new unique (never used) address. Displaying your balance Dash Wallet returns the balance in duffs (1 Dash is equal to 100.000.000 duffs) getTotalBalance() function takes into account confirmed and unconfirmed transactions (not included in a block). It is recommended to check the confirmed balance before making a payment: async function showBalance() { const account = await client.wallet.getAccount(); const totalBalance = account.getTotalBalance(); const confirmedBalance = account.getConfirmedBalance(); const unconfirmedBalance = account.getUnconfirmedBalance(); console.log(`Account balance: Confirmed: ${confirmedBalance} Unconfirmed: ${unconfirmedBalance} Total: ${totalBalance} `); } Listen for event on received transaction When a new unconfirmed transaction is received, you can receive an event, and then validate the address or perform an action if needed. // FETCHED/UNCONFIRMED_TRANSACTION event is currently disabled async function listenUnconfirmedTransaction() { const account = await client.wallet.getAccount(); account.on('FETCHED/UNCONFIRMED_TRANSACTION', (data) => { console.dir(data); }); } Get address at specific index In case you want to retrieve an address at specific index: async function getAddressAtIndex() { const account = await client.wallet.getAccount(); const { address: externalAddress } = account.getAddress(2); const { address: internalAddress } = account.getAddress(2, 'internal'); }","title":"Receive money and check balance"},{"location":"SDK/examples/receive-money-and-check-balance/#receive-money-and-display-balance","text":"Initialize the SDK Client with your generated mnemonic passed as an option. const Dash = require(\"dash\"); const mnemonic = ''// your mnemonic here. const client = new Dash.Client({ wallet: { mnemonic, } }); async function showBalance() { const account = await client.wallet.getAccount(); const totalBalance = account.getTotalBalance(); console.log(`Account's total balance: ${totalBalance} duffs`); } Having your client instance set up, you will be able to access the account and wallet instance generated from your mnemonic. By default getAccount() returns the first BIP44 account. You can read more on how to use a different account .","title":"Receive money and display balance"},{"location":"SDK/examples/receive-money-and-check-balance/#generate-a-receiving-address","text":"Dash wallet supports two different types of addresses: - external addresses used for receiving funds from other addresses - internal addresses used for change outputs of outgoing transactions - For your privacy, you might want to generate a new address for each payment: async function generateUnusedAddress() { const account = await client.wallet.getAccount(); const { address } = account.getUnusedAddress(); console.log(`Unused external address: ${address}`); } This above code will generate a new unique (never used) address.","title":"Generate a receiving address"},{"location":"SDK/examples/receive-money-and-check-balance/#displaying-your-balance","text":"Dash Wallet returns the balance in duffs (1 Dash is equal to 100.000.000 duffs) getTotalBalance() function takes into account confirmed and unconfirmed transactions (not included in a block). It is recommended to check the confirmed balance before making a payment: async function showBalance() { const account = await client.wallet.getAccount(); const totalBalance = account.getTotalBalance(); const confirmedBalance = account.getConfirmedBalance(); const unconfirmedBalance = account.getUnconfirmedBalance(); console.log(`Account balance: Confirmed: ${confirmedBalance} Unconfirmed: ${unconfirmedBalance} Total: ${totalBalance} `); }","title":"Displaying your balance"},{"location":"SDK/examples/receive-money-and-check-balance/#listen-for-event-on-received-transaction","text":"When a new unconfirmed transaction is received, you can receive an event, and then validate the address or perform an action if needed. // FETCHED/UNCONFIRMED_TRANSACTION event is currently disabled async function listenUnconfirmedTransaction() { const account = await client.wallet.getAccount(); account.on('FETCHED/UNCONFIRMED_TRANSACTION', (data) => { console.dir(data); }); }","title":"Listen for event on received transaction"},{"location":"SDK/examples/receive-money-and-check-balance/#get-address-at-specific-index","text":"In case you want to retrieve an address at specific index: async function getAddressAtIndex() { const account = await client.wallet.getAccount(); const { address: externalAddress } = account.getAddress(2); const { address: internalAddress } = account.getAddress(2, 'internal'); }","title":"Get address at specific index"},{"location":"SDK/examples/sign-and-verify-messages/","text":"Sign and verify messages Dash SDK exports the Message constructor inside the Core namespace new Dash.Core.Message const Dash = require('dash'); const mnemonic = ''; const client = new Dash.Client({ wallet: { mnemonic, }, }); async function signAndVerify() { const account = await client.wallet.getAccount(); const pk = new Dash.Core.PrivateKey(); const message = new Dash.Core.Message('hello, world'); const signed = account.sign(message, pk); const verified = message.verify(pk.toAddress().toString(), signed.toString()); }","title":"Sign and verify messages"},{"location":"SDK/examples/sign-and-verify-messages/#sign-and-verify-messages","text":"Dash SDK exports the Message constructor inside the Core namespace new Dash.Core.Message const Dash = require('dash'); const mnemonic = ''; const client = new Dash.Client({ wallet: { mnemonic, }, }); async function signAndVerify() { const account = await client.wallet.getAccount(); const pk = new Dash.Core.PrivateKey(); const message = new Dash.Core.Message('hello, world'); const signed = account.sign(message, pk); const verified = message.verify(pk.toAddress().toString(), signed.toString()); }","title":"Sign and verify messages"},{"location":"SDK/examples/use-different-account/","text":"Using a different account Clients initialized with a mnemonic support multiple accounts as defined in BIP44 . By default client.wallet.getAccount() returns the account at index 0 . To access other accounts, pass the index option: const secondAccount = await client.wallet.getAccount({ index: 1 })","title":"Use different account"},{"location":"SDK/examples/use-different-account/#using-a-different-account","text":"Clients initialized with a mnemonic support multiple accounts as defined in BIP44 . By default client.wallet.getAccount() returns the account at index 0 . To access other accounts, pass the index option: const secondAccount = await client.wallet.getAccount({ index: 1 })","title":"Using a different account"},{"location":"SDK/getting-started/about-schemas/","text":"About Schemas Schemas represents the application data structure, a JSON Schema language based set of rules that allows the creation of a Data Contract. You can read more in the Dash Platform Documentation - Data contract section .","title":"About schemas"},{"location":"SDK/getting-started/about-schemas/#about-schemas","text":"Schemas represents the application data structure, a JSON Schema language based set of rules that allows the creation of a Data Contract. You can read more in the Dash Platform Documentation - Data contract section .","title":"About Schemas"},{"location":"SDK/getting-started/core-concepts/","text":"Core concepts The Dash Core Developer Guide will answer most of questions about the fundamentals of Dash. However, some elements provided by the SDK need to be grasped, so we will quickly cover some of those. Wallet At the core of Dash is the Payment Chain. In order to be able to transact on it, one needs to have a set of UTXOs that are controlled by a Wallet instance. In order to access your UTXO, you will have to provide a valid mnemonic that will unlock the Wallet and automatically fetch the associated UTXOs. When an SDK instance is created, you can access your wallet via the client.wallet variable. (Check wallet-lib documentation for more details) Account Since the introduction of deterministic wallets ( BIP44 ), a wallet is represented by multiple accounts. It is the instance you will use most of the time for receiving or broadcasting payments. You can access your account with client.getWalletAccount() . See how to use a different account if you need to get an account at a specific index. App Schema and Contracts The Dash Platform Chain provides developers with the ability to create applications. Each application requires a set of rules and conditions described as a portable document in the form of a JSON Schema. When registered, those applications schemas are called contracts and contains a contractId (namespace : client.platform.contracts ). By default, this library supports Dash Platform Name Service (DPNS) (to attach a name to an identity), under the namespace client.platform.names for testnet. See: how to use multiple apps","title":"Core concepts"},{"location":"SDK/getting-started/core-concepts/#core-concepts","text":"The Dash Core Developer Guide will answer most of questions about the fundamentals of Dash. However, some elements provided by the SDK need to be grasped, so we will quickly cover some of those.","title":"Core concepts"},{"location":"SDK/getting-started/core-concepts/#wallet","text":"At the core of Dash is the Payment Chain. In order to be able to transact on it, one needs to have a set of UTXOs that are controlled by a Wallet instance. In order to access your UTXO, you will have to provide a valid mnemonic that will unlock the Wallet and automatically fetch the associated UTXOs. When an SDK instance is created, you can access your wallet via the client.wallet variable. (Check wallet-lib documentation for more details)","title":"Wallet"},{"location":"SDK/getting-started/core-concepts/#account","text":"Since the introduction of deterministic wallets ( BIP44 ), a wallet is represented by multiple accounts. It is the instance you will use most of the time for receiving or broadcasting payments. You can access your account with client.getWalletAccount() . See how to use a different account if you need to get an account at a specific index.","title":"Account"},{"location":"SDK/getting-started/core-concepts/#app-schema-and-contracts","text":"The Dash Platform Chain provides developers with the ability to create applications. Each application requires a set of rules and conditions described as a portable document in the form of a JSON Schema. When registered, those applications schemas are called contracts and contains a contractId (namespace : client.platform.contracts ). By default, this library supports Dash Platform Name Service (DPNS) (to attach a name to an identity), under the namespace client.platform.names for testnet. See: how to use multiple apps","title":"App Schema and Contracts"},{"location":"SDK/getting-started/dash-platform-applications/","text":"DPNS DPNS is handled in the Dash SDK Client under the namespace client.platform.names.*' . Read more here DashPay The DashPay contract is registered on testnet under contract id Bwr4WHCPz5rFVAD87RqTs3izo4zpzwsEdKPWUT1NS1C7 . Its functionality is not incorporated with the Dash SDK at this time.","title":"Dash platform applications"},{"location":"SDK/getting-started/dash-platform-applications/#dpns","text":"DPNS is handled in the Dash SDK Client under the namespace client.platform.names.*' . Read more here","title":"DPNS"},{"location":"SDK/getting-started/dash-platform-applications/#dashpay","text":"The DashPay contract is registered on testnet under contract id Bwr4WHCPz5rFVAD87RqTs3izo4zpzwsEdKPWUT1NS1C7 . Its functionality is not incorporated with the Dash SDK at this time.","title":"DashPay"},{"location":"SDK/getting-started/multiple-apps/","text":"Working with multiple apps When working with other registered contracts, you will need to know their contractId and reference it in the SDK constructor. Assuming a contract DashPay has the following contractId: \"77w8Xqn25HwJhjodrHW133aXhjuTsTv9ozQaYpSHACE3\" . You can then pass it as an option. const client = new Dash.Client({ apps: { dashpay: { contractId: '77w8Xqn25HwJhjodrHW133aXhjuTsTv9ozQaYpSHACE3' } } }); This allow the method client.platform.documents.get to provide you field selection. Therefore, if the contract has a profile field that you wish to access, the SDK will allow you to use dot-syntax for access : const bobProfile = await client.platform.documents.get('dashpay.profile', { name: 'bob' });","title":"Working with multiple apps"},{"location":"SDK/getting-started/multiple-apps/#working-with-multiple-apps","text":"When working with other registered contracts, you will need to know their contractId and reference it in the SDK constructor. Assuming a contract DashPay has the following contractId: \"77w8Xqn25HwJhjodrHW133aXhjuTsTv9ozQaYpSHACE3\" . You can then pass it as an option. const client = new Dash.Client({ apps: { dashpay: { contractId: '77w8Xqn25HwJhjodrHW133aXhjuTsTv9ozQaYpSHACE3' } } }); This allow the method client.platform.documents.get to provide you field selection. Therefore, if the contract has a profile field that you wish to access, the SDK will allow you to use dot-syntax for access : const bobProfile = await client.platform.documents.get('dashpay.profile', { name: 'bob' });","title":"Working with multiple apps"},{"location":"SDK/getting-started/quickstart/","text":"Quick start In order to use this library, you will need to add our NPM package to your project. Having NodeJS installed, just type : npm install dash Initialization Let's create a Dash SDK client instance specifying both our mnemonic and the schema we wish to work with. const Dash = require('dash'); const opts = { wallet: { mnemonic: \"arena light cheap control apple buffalo indicate rare motor valid accident isolate\", }, }; const client = new Dash.Client(opts); client.wallet.getAccount().then(async (account) => { // Do something }) Quick note: If no mnemonic is provided or mnemonic: null is passed inside the wallet option, a new mnemonic will be generated. Make a payment client.wallet.getAccount().then(async (account) => { const transaction = account.createTransaction({ recipient: 'yixnmigzC236WmTXp9SBZ42csyp9By6Hw8', amount: 0.12, }); await account.broadcastTransaction(transaction); }); Interact with Dash Platform See the Tutorial section of the Dash Platform documentation for examples.","title":"Quick start"},{"location":"SDK/getting-started/quickstart/#quick-start","text":"In order to use this library, you will need to add our NPM package to your project. Having NodeJS installed, just type : npm install dash","title":"Quick start"},{"location":"SDK/getting-started/quickstart/#initialization","text":"Let's create a Dash SDK client instance specifying both our mnemonic and the schema we wish to work with. const Dash = require('dash'); const opts = { wallet: { mnemonic: \"arena light cheap control apple buffalo indicate rare motor valid accident isolate\", }, }; const client = new Dash.Client(opts); client.wallet.getAccount().then(async (account) => { // Do something }) Quick note: If no mnemonic is provided or mnemonic: null is passed inside the wallet option, a new mnemonic will be generated.","title":"Initialization"},{"location":"SDK/getting-started/quickstart/#make-a-payment","text":"client.wallet.getAccount().then(async (account) => { const transaction = account.createTransaction({ recipient: 'yixnmigzC236WmTXp9SBZ42csyp9By6Hw8', amount: 0.12, }); await account.broadcastTransaction(transaction); });","title":"Make a payment"},{"location":"SDK/getting-started/quickstart/#interact-with-dash-platform","text":"See the Tutorial section of the Dash Platform documentation for examples.","title":"Interact with Dash Platform"},{"location":"SDK/getting-started/with-typescript/","text":"In order to use Dash SDK with TypeScript. Create an index.ts file import Dash from 'dash'; const clientOpts = { wallet: { mnemonic: null, // Will generate a new address, you should keep it. }, }; const client = new Dash.Client(clientOpts); const initializeAccount = async () => { const account = await client.wallet.getAccount(); const balance = account.getTotalBalance(); console.log(`Account balance: ${balance}`) } Have a following tsconfig.json file { \"compilerOptions\": { \"module\": \"commonjs\", \"moduleResolution\": \"node\", \"esModuleInterop\": true } } Compile: tsc -p tsconfig.json Run: node index.js","title":"With typescript"},{"location":"SDK/platform/about-platform/","text":"About Dash Platform The Dash Platform provides a technology stack on the top of Dash Network that allows creation of feature-rich decentralized applications. You can learn more from the Dash Platform Documentation - What is Dash Platform? Platform components DAPI: A decentralized API that runs on all Masternodes and offers gRPC endpoints for retrieving payment chain metadata (blocks, transactions), as well as application data (documents, contracts, identities). Drive: Application chain storage layer where the data defined by Data Contracts is stored and managed. DPNS: Naming service provided by a Dash Platform App","title":"About platform"},{"location":"SDK/platform/about-platform/#about-dash-platform","text":"The Dash Platform provides a technology stack on the top of Dash Network that allows creation of feature-rich decentralized applications. You can learn more from the Dash Platform Documentation - What is Dash Platform?","title":"About Dash Platform"},{"location":"SDK/platform/about-platform/#platform-components","text":"DAPI: A decentralized API that runs on all Masternodes and offers gRPC endpoints for retrieving payment chain metadata (blocks, transactions), as well as application data (documents, contracts, identities). Drive: Application chain storage layer where the data defined by Data Contracts is stored and managed. DPNS: Naming service provided by a Dash Platform App","title":"Platform components"},{"location":"SDK/platform/contracts/about-contracts/","text":"What is a contract Contracts are registered sets of rules defined in a JSON Application Schema . See the Dash Platform documentation for more information about Data Contracts .","title":"About contracts"},{"location":"SDK/platform/contracts/about-contracts/#what-is-a-contract","text":"Contracts are registered sets of rules defined in a JSON Application Schema . See the Dash Platform documentation for more information about Data Contracts .","title":"What is a contract"},{"location":"SDK/platform/contracts/create/","text":"Usage : client.platform.contracts.create(contractDefinitions, identity) Description : This method will return a Contract object initialized with the parameters defined and apply to the used identity. Parameters: parameters type required Description contractDefinitions JSONDataContract yes The defined JSON Application Schema identity Identity yes A valid registered application identity Example : const identityId = '';// Your identity identifier. // Your valid json contract definitions const contractDefinitions = { note: { properties: { message: { type: \"string\" } }, additionalProperties: false } }; const identity = await client.platform.identities.get(identityId); const contract = client.platform.contracts.create(contractDefinitions, identity); // You can use the validate method from DPP to validate the created contract const validationResult = client.platform.dpp.dataContract.validate(contract); Note : When your contract is created, it will only exist locally. Use the publish method to register it. Returns: Contract.","title":"Create"},{"location":"SDK/platform/contracts/get/","text":"Usage : client.platform.contracts.get(contractId) Description : This method will allow you to fetch back a contract from its id. Parameters: parameters type required Description identifier string yes Will fetch back the contract matching the identifier Example : await client.platform.contracts.get('77w8Xqn25HwJhjodrHW133aXhjuTsTv9ozQaYpSHACE3') Returns: Contract (or null if it's not a registered contract).","title":"Get"},{"location":"SDK/platform/contracts/publish/","text":"Usage : client.platform.contracts.publish(contract, identity) Description : This method will sign and broadcast any valid contract. Parameters: parameters type required Description contract Contract yes A valid created contract identity Identity yes A valid registered application identity Example : const identityId = '';// Your identity identifier. const identity = await client.platform.identities.get(identityId); // See the contract.create documentation for more on how to create a dataContract const contract = await client.platform.contracts.create(contractDefinitions, identity); await client.platform.contracts.publish(contract, identity); Returns : DataContractCreateTransition.","title":"Publish"},{"location":"SDK/platform/contracts/update/","text":"Usage : client.platform.contracts.update(contract, identity) Description : This method will sign and broadcast an updated valid contract. Parameters: parameters type required Description contract Contract yes A valid created contract identity Identity yes A valid registered application identity Returns: DataContractUpdateTransition.","title":"Update"},{"location":"SDK/platform/documents/about-documents/","text":"What is a document Documents in Dash Platform are similar to those in standard document-oriented databases (MongoDB,...). They represent a record consisting of one, or multiples field-value pairs and should respect the structure of the dataContract on which they are submitted in. See more on the Dash Platform documentation about Data Contract .","title":"About documents"},{"location":"SDK/platform/documents/about-documents/#what-is-a-document","text":"Documents in Dash Platform are similar to those in standard document-oriented databases (MongoDB,...). They represent a record consisting of one, or multiples field-value pairs and should respect the structure of the dataContract on which they are submitted in. See more on the Dash Platform documentation about Data Contract .","title":"What is a document"},{"location":"SDK/platform/documents/broadcast/","text":"Usage : client.platform.document.broadcast(documents, identity) Description : This method will broadcast the document on the Application Chain Parameters: parameters type required Description documents Object yes documents.create Document[] no array of valid created document to create documents.replace Document[] no array of valid created document to replace documents.delete Document[] no array of valid created document to delete identity Identity yes A valid registered identity Example : const identityId = '';// Your identity identifier const identity = await client.platform.identities.get(identityId); const helloWorldDocument = await client.platform.documents.create( // Assuming a contract tutorialContract is registered with a field note 'tutorialContract.note', identity, { message: 'Hello World'}, ); await client.platform.documents.broadcast({ create: [helloWorldDocument] }, identity); Returns: documents.","title":"Broadcast"},{"location":"SDK/platform/documents/create/","text":"Usage : client.platform.documents.create(typeLocator, identity, documentOpts) Description : This method will return a Document object initialized with the parameters defined and apply to the used identity. Parameters: parameters type required Description dotLocator string yes Field of a specific application, under the form appName.fieldName identity Identity yes A valid registered identity docOpts Object yes A valid data that match the data contract structure Example : const identityId = '';// Your identity identifier const identity = await client.platform.identities.get(identityId); const helloWorldDocument = await client.platform.documents.create( // Assume a contract helloWorldContract is registered with a field note 'helloWorldContract.note', identity, { message: 'Hello World'}, ); Note : When your document is created, it will only exist locally, use the broadcast method to register it. Returns: Document","title":"Create"},{"location":"SDK/platform/documents/get/","text":"Usage : client.platform.documents.get(typeLocator, opts) Description : This method will allow you to fetch back documents matching the provided parameters. Parameters: parameters type required Description typeLocator string yes Field of a specific application, under the form appName.fieldName opts object no (default: {}) Query options of the request Queries options : parameters type required Description where array no Mongo-like where query orderBy array no Mongo-like orderBy query limit integer no how many objects to fetch startAt integer no number of objects to skip startAfter integer no exclusive skip Learn more about query syntax at https://dashplatform.readme.io/docs/reference-query-syntax Example : const queryOpts = { where: [ ['normalizedLabel', '==', 'alice'], ['normalizedParentDomainName', '==', 'dash'], ], }; await client.platform.documents.get('dpns.domain', queryOpts);","title":"Get"},{"location":"SDK/platform/identities/about-identity/","text":"What is an identity An Identity is a blockchain-based identifier for individuals (users) and applications. Identities are the atomic element that, when linked with additional applications, can be extended to provide new functionality. Read more on the Dash Platform documentation about Identity . You might also want to consult the usage for the DPNS Name Service in order to attach a name to your created identity. Credits Each identity contains a credit balance. The ratio is 1 duff = 1000 credits.","title":"About identity"},{"location":"SDK/platform/identities/about-identity/#what-is-an-identity","text":"An Identity is a blockchain-based identifier for individuals (users) and applications. Identities are the atomic element that, when linked with additional applications, can be extended to provide new functionality. Read more on the Dash Platform documentation about Identity . You might also want to consult the usage for the DPNS Name Service in order to attach a name to your created identity.","title":"What is an identity"},{"location":"SDK/platform/identities/about-identity/#credits","text":"Each identity contains a credit balance. The ratio is 1 duff = 1000 credits.","title":"Credits"},{"location":"SDK/platform/identities/get/","text":"Usage : client.platform.identities.get(identityId) Description : This method will allow you to fetch back an identity from its id. Parameters: parameters type required Description identifier string yes Will fetch back the identity matching the identifier Example : await client.platform.identities.get('3GegupTgRfdN9JMS8R6QXF3B2VbZtiw63eyudh1oMJAk') Returns: Identity (or null if it does not exist).","title":"Get"},{"location":"SDK/platform/identities/register/","text":"Usage : client.platform.identities.register() Description : This method will register a new identity for you. Parameters: parameters type required Description fundingAmount number no Defaults: 10000. Allow to set a funding amount in duffs (satoshis). Example : await client.platform.identities.register() Note : The created identity will be associated to the active account. You might want to know more about how to change your active account . Returns: Identity.","title":"Register"},{"location":"SDK/platform/identities/topUp/","text":"Usage : client.platform.identities.topUp(identity, amount) Description : This method will topup the provided identity's balance. The identity balance might slightly vary from the topped up amount because of the transaction fee estimation. Parameters: parameters type required Description identity Identity yes A valid registered identity amount number yes A duffs (satoshis) value corresponding to the amount you want to top up to the identity. Example : const identityId = '';// Your identity identifier const identity = await client.platform.identities.get(identityId); await client.platform.identities.topUp(identity.getId(), 10000); console.log(`New identity balance: ${identity.balance}`) Returns: Boolean.","title":"topUp"},{"location":"SDK/platform/names/about-dpns/","text":"What is DPNS DPNS is a special Dash Platform Application that is intended to provide a naming service for the Application Chain. Decoupling name from the blockchain identity enables a unique user experience coupled with the highest security while remaining compatible with Decentralized Identifiers . Limitation: max length of 63 characters on charset 0-9 , A-Z (case insensitive), - . Domain names are linked to an Identity.","title":"About dpns"},{"location":"SDK/platform/names/about-dpns/#what-is-dpns","text":"DPNS is a special Dash Platform Application that is intended to provide a naming service for the Application Chain. Decoupling name from the blockchain identity enables a unique user experience coupled with the highest security while remaining compatible with Decentralized Identifiers . Limitation: max length of 63 characters on charset 0-9 , A-Z (case insensitive), - . Domain names are linked to an Identity.","title":"What is DPNS"},{"location":"SDK/platform/names/register/","text":"Usage : client.platform.names.register(name, records, identity) Description : This method will create a DPNS record matching your identity to the user or appname defined. Parameters: parameters type required Description name String yes An alphanumeric (1-63 character) value used for human-identification (can contain - but not as the first or last character). If a name with no parent domain is entered, '.dash' is used. records Object yes records object having only one of the following items records.dashUniqueIdentityId String no Unique Identity ID for this name record records.dashAliasIdentityId String no Used to signify that this name is the alias for another id identity Identity yes A valid registered identity Example : await client.platform.names.register('alice', { dashUniqueIdentityId: identity.getId() }, identity) Returns: the created domain document","title":"Register"},{"location":"SDK/platform/names/resolve/","text":"Usage : client.platform.names.resolve('<name>.dash') Description : This method will allow you to resolve a DPNS record from its humanized name. Parameters: parameters type required Description name String yes An alphanumeric (2-63) value used for human-identification (can contains - ) Example : await client.platform.names.resolve('alice.dash') Returns : Document (or null if do not exist).","title":"Resolve"},{"location":"SDK/platform/names/resolveByRecord/","text":"Usage : client.platform.names.resolveByRecord(record, value) Description : This method will allow you to resolve a DPNS record by identity ID. Parameters: parameters type required Description record String yes Type of the record ( dashUniqueIdentityId or dashAliasIdentityId ) value String yes Identifier value for the record Example : This example will describe how to resolve names by the dash unique identity id. const identityId = '3ge4yjGinQDhxh2aVpyLTQaoka45BkijkoybfAkDepoN'; const document = await client.platform.names.resolveByRecord('dashUniqueIdentityId', identityId); Returns: array of Document.","title":"resolveByRecord"},{"location":"SDK/platform/names/search/","text":"Usage : client.platform.names.search(labelPrefix, parentDomain) Description : This method will allow you to search all records matching the label prefix on the specified parent domain. Parameters: parameters type required Description labelPrefix String yes label prefix to search for parentDomain String yes parent domain name on which to perform the search Example : This example will describe how to search all names on the parent domain dash that starts with the label prefix al . It will resolves names documents such as alice , alex etc... const labelPrefix = 'al'; const parentDomain = 'dash'; const document = await client.platform.names.search(labelPrefix, parentDomain); Returns: Documents matching the label prefix on the parent domain.","title":"Search"},{"location":"SDK/usage/dapi/","text":"About DAPI DAPI (Decentralized API) is a distributed and decentralized endpoints provided by the Masternode Network. Get the DAPI-Client instance const dapiClient = client.getDAPIClient(); The usage is then described here .","title":"Dapi"},{"location":"SDK/usage/dapi/#about-dapi","text":"DAPI (Decentralized API) is a distributed and decentralized endpoints provided by the Masternode Network.","title":"About DAPI"},{"location":"SDK/usage/dapi/#get-the-dapi-client-instance","text":"const dapiClient = client.getDAPIClient(); The usage is then described here .","title":"Get the DAPI-Client instance"},{"location":"SDK/usage/dashcorelib-primitives/","text":"Dashcore Lib primitives All Dashcore lib primitives are exposed via the Core namespace. const Dash = require('dash'); const { Core: { Block, Transaction, Address, // ... } } = Dash; Transaction The Transaction primitive allows creating and manipulating transactions. It also allows signing transactions with a private key. Supports fee control and input/output access (which allows passing a specific script). const { Transaction } = Dash.Core; const tx = new Transaction(txProps) Access the Transaction documentation on dashevo/dashcore-lib Address Standardized representation of a Dash Address. Address can be instantiated from a String, PrivateKey, PublicKey, HDPrivateKey or HdPublicKey. Pay-to-script-hash (P2SH) multi-signature addresses from an array of PublicKeys are also supported. const { Address } = Dash.Core; Access the Address documentation on dashevo/dashcore-lib Block Given a binary representation of the block as input, the Block class allows you to have a deserialized representation of a Block or its header. It also allows validating the transactions in the block against the header merkle root. The block's transactions can also be explored by iterating over elements in array ( block.transactions ). const { Block } = Dash.Core; Access the Block documentation on dashevo/dashcore-lib UnspentOutput Representation of an UnspentOutput (also called UTXO as in Unspent Transaction Output). Mostly useful in association with a Transaction and for Scripts. const { UnspentOutput } = Dash.Core.Transaction; Access the UnspentOutput documentation on dashevo/dashcore-lib HDPublicKey Hierarchical Deterministic (HD) version of the PublicKey. Used internally by Wallet-lib and for exchange between peers (DashPay) const { HDPublicKey } = Dash.Core;` Access the HDKeys documentation on dashevo/dashcore-lib HDPrivateKey Hierarchical Deterministic (HD) version of the PrivateKey. Used internally by Wallet-lib. const { HDPrivateKey } = Dash.Core; Access the HDKeys documentation on dashevo/dashcore-lib PublicKey const { PublicKey } = Dash.Core; Access the PublicKey documentation on dashevo/dashcore-lib PrivateKey const { PrivateKey } = Dash.Core; Access the PrivateKey documentation on dashevo/dashcore-lib Mnemonic Implementation of BIP39 Mnemonic code for generative deterministic keys . Generates a random mnemonic with the chosen language, validates a mnemonic or returns the associated HDPrivateKey. const { Mnemonic } = Dash.Core; Access the Mnemonic documentation on dashevo/dashcore-lib Network A representation of the internal parameters relative to the selected network. By default, all primitives works with 'livenet'. const { Network } = Dash.Core; Access the Network documentation on dashevo/dashcore-lib Script const { Script } = Dash.Core.Transaction; Access the Script documentation on dashevo/dashcore-lib Input const { Input } = Dash.Core.Transaction; Access the Transaction documentation on dashevo/dashcore-lib Output const { Output } = Dash.Core.Transaction; Access the Transaction documentation on dashevo/dashcore-lib","title":"Dashcore Lib primitives"},{"location":"SDK/usage/dashcorelib-primitives/#dashcore-lib-primitives","text":"All Dashcore lib primitives are exposed via the Core namespace. const Dash = require('dash'); const { Core: { Block, Transaction, Address, // ... } } = Dash;","title":"Dashcore Lib primitives"},{"location":"SDK/usage/dashcorelib-primitives/#transaction","text":"The Transaction primitive allows creating and manipulating transactions. It also allows signing transactions with a private key. Supports fee control and input/output access (which allows passing a specific script). const { Transaction } = Dash.Core; const tx = new Transaction(txProps) Access the Transaction documentation on dashevo/dashcore-lib","title":"Transaction"},{"location":"SDK/usage/dashcorelib-primitives/#address","text":"Standardized representation of a Dash Address. Address can be instantiated from a String, PrivateKey, PublicKey, HDPrivateKey or HdPublicKey. Pay-to-script-hash (P2SH) multi-signature addresses from an array of PublicKeys are also supported. const { Address } = Dash.Core; Access the Address documentation on dashevo/dashcore-lib","title":"Address"},{"location":"SDK/usage/dashcorelib-primitives/#block","text":"Given a binary representation of the block as input, the Block class allows you to have a deserialized representation of a Block or its header. It also allows validating the transactions in the block against the header merkle root. The block's transactions can also be explored by iterating over elements in array ( block.transactions ). const { Block } = Dash.Core; Access the Block documentation on dashevo/dashcore-lib","title":"Block"},{"location":"SDK/usage/dashcorelib-primitives/#unspentoutput","text":"Representation of an UnspentOutput (also called UTXO as in Unspent Transaction Output). Mostly useful in association with a Transaction and for Scripts. const { UnspentOutput } = Dash.Core.Transaction; Access the UnspentOutput documentation on dashevo/dashcore-lib","title":"UnspentOutput"},{"location":"SDK/usage/dashcorelib-primitives/#hdpublickey","text":"Hierarchical Deterministic (HD) version of the PublicKey. Used internally by Wallet-lib and for exchange between peers (DashPay) const { HDPublicKey } = Dash.Core;` Access the HDKeys documentation on dashevo/dashcore-lib","title":"HDPublicKey"},{"location":"SDK/usage/dashcorelib-primitives/#hdprivatekey","text":"Hierarchical Deterministic (HD) version of the PrivateKey. Used internally by Wallet-lib. const { HDPrivateKey } = Dash.Core; Access the HDKeys documentation on dashevo/dashcore-lib","title":"HDPrivateKey"},{"location":"SDK/usage/dashcorelib-primitives/#publickey","text":"const { PublicKey } = Dash.Core; Access the PublicKey documentation on dashevo/dashcore-lib","title":"PublicKey"},{"location":"SDK/usage/dashcorelib-primitives/#privatekey","text":"const { PrivateKey } = Dash.Core; Access the PrivateKey documentation on dashevo/dashcore-lib","title":"PrivateKey"},{"location":"SDK/usage/dashcorelib-primitives/#mnemonic","text":"Implementation of BIP39 Mnemonic code for generative deterministic keys . Generates a random mnemonic with the chosen language, validates a mnemonic or returns the associated HDPrivateKey. const { Mnemonic } = Dash.Core; Access the Mnemonic documentation on dashevo/dashcore-lib","title":"Mnemonic"},{"location":"SDK/usage/dashcorelib-primitives/#network","text":"A representation of the internal parameters relative to the selected network. By default, all primitives works with 'livenet'. const { Network } = Dash.Core; Access the Network documentation on dashevo/dashcore-lib","title":"Network"},{"location":"SDK/usage/dashcorelib-primitives/#script","text":"const { Script } = Dash.Core.Transaction; Access the Script documentation on dashevo/dashcore-lib","title":"Script"},{"location":"SDK/usage/dashcorelib-primitives/#input","text":"const { Input } = Dash.Core.Transaction; Access the Transaction documentation on dashevo/dashcore-lib","title":"Input"},{"location":"SDK/usage/dashcorelib-primitives/#output","text":"const { Output } = Dash.Core.Transaction; Access the Transaction documentation on dashevo/dashcore-lib","title":"Output"},{"location":"SDK/wallet/about-wallet-lib/","text":"About Wallet-lib When Dash.Client is initiated with a mnemonic property, a wallet instance becomes accessible via client.wallet property. To initialize the wallet account and synchronize with the network, use client.wallet.getAccount() . Find out more about the Wallet in its complete documentation","title":"About wallet lib"},{"location":"SDK/wallet/about-wallet-lib/#about-wallet-lib","text":"When Dash.Client is initiated with a mnemonic property, a wallet instance becomes accessible via client.wallet property. To initialize the wallet account and synchronize with the network, use client.wallet.getAccount() . Find out more about the Wallet in its complete documentation","title":"About Wallet-lib"},{"location":"SDK/wallet/accounts/","text":"Getting an account When Wallet is initialized with mnemonic , it holds multiple Accounts according to BIP44. Each Account holds the keys needed to make a payments from it. Wallet's getAccount method used to access an account: const client = new Dash.Client({ wallet: { mnemonic: \"maximum blast eight orchard waste wood gospel siren parent deer athlete impact\", }, }); const account = await client.wallet.getAccount() // Do something with account As optional parameter, an integer representing the account index can be passed as parameter. By default, index account on call is 0. client.wallet.getAccount({ index: 1 }) Awaiting for the getAccount() promise is necessary to ensure the wallet is synced-up with the network and make sure that the UTXO set is ready to be used for payment/signing.","title":"Accounts"},{"location":"SDK/wallet/accounts/#getting-an-account","text":"When Wallet is initialized with mnemonic , it holds multiple Accounts according to BIP44. Each Account holds the keys needed to make a payments from it. Wallet's getAccount method used to access an account: const client = new Dash.Client({ wallet: { mnemonic: \"maximum blast eight orchard waste wood gospel siren parent deer athlete impact\", }, }); const account = await client.wallet.getAccount() // Do something with account As optional parameter, an integer representing the account index can be passed as parameter. By default, index account on call is 0. client.wallet.getAccount({ index: 1 }) Awaiting for the getAccount() promise is necessary to ensure the wallet is synced-up with the network and make sure that the UTXO set is ready to be used for payment/signing.","title":"Getting an account"},{"location":"SDK/wallet/signing-encrypt/","text":"Obtain account const account = await client.wallet.getAccount(); Sign a Transaction const tx = new Dash.Core.Transaction({ // ...txOpts }); const signedTx = account.sign(tx); Encrypt a message const message = 'Something'; const signedMessage = account.encrypt('AES', message, 'secret'); Decrypt a message const encrypted = 'U2FsdGVkX19JLa+1UpbMcut1/QFWLMlKUS+iqz+7Wl4='; const message = account.decrypt('AES', encrypted, 'secret');","title":"Signing encrypt"},{"location":"SDK/wallet/signing-encrypt/#obtain-account","text":"const account = await client.wallet.getAccount();","title":"Obtain account"},{"location":"SDK/wallet/signing-encrypt/#sign-a-transaction","text":"const tx = new Dash.Core.Transaction({ // ...txOpts }); const signedTx = account.sign(tx);","title":"Sign a Transaction"},{"location":"SDK/wallet/signing-encrypt/#encrypt-a-message","text":"const message = 'Something'; const signedMessage = account.encrypt('AES', message, 'secret');","title":"Encrypt a message"},{"location":"SDK/wallet/signing-encrypt/#decrypt-a-message","text":"const encrypted = 'U2FsdGVkX19JLa+1UpbMcut1/QFWLMlKUS+iqz+7Wl4='; const message = account.decrypt('AES', encrypted, 'secret');","title":"Decrypt a message"},{"location":"Wallet-library/","text":"Wallet-lib A pure and extensible JavaScript Wallet Library for Dash What it is Wallet-lib provides all the wallet features needed for node and browser usage. From being able to display an account balance, to paying to another address, passing by the need to automate back-end task related to a cold-storage. Wallet-lib allows you to easily work with Wallets/Accounts for HDWallets, or from just a single private key. It also allows you to monitor public keys and HDPubKey. You might also wish to create your own set of plugins or your own coin selection logic. Install ES5/ES6 via NPM In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/wallet-lib CDN Standalone For browser usage, you can also directly rely on unpkg : <script src=\"https://unpkg.com/@dashevo/wallet-lib\"></script> Usage In your file, where you want to execute it : const { Wallet, EVENTS } = require('@dashevo/wallet-lib'); const wallet = new Wallet(); // We can dump our initialization parameters const mnemonic = wallet.exportWallet(); wallet.getAccount().then((account) => { // At this point, account has fetch all UTXOs if they exists const balance = account.getTotalBalance(); console.log(`Balance: ${balance}`); // We easily can get a new address to fund const { address } = account.getUnusedAddress(); }); Licence MIT \u00a9 Dash Core Group, Inc.","title":"Index"},{"location":"Wallet-library/#wallet-lib","text":"A pure and extensible JavaScript Wallet Library for Dash","title":"Wallet-lib"},{"location":"Wallet-library/#what-it-is","text":"Wallet-lib provides all the wallet features needed for node and browser usage. From being able to display an account balance, to paying to another address, passing by the need to automate back-end task related to a cold-storage. Wallet-lib allows you to easily work with Wallets/Accounts for HDWallets, or from just a single private key. It also allows you to monitor public keys and HDPubKey. You might also wish to create your own set of plugins or your own coin selection logic.","title":"What it is"},{"location":"Wallet-library/#install","text":"","title":"Install"},{"location":"Wallet-library/#es5es6-via-npm","text":"In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/wallet-lib","title":"ES5/ES6 via NPM"},{"location":"Wallet-library/#cdn-standalone","text":"For browser usage, you can also directly rely on unpkg : <script src=\"https://unpkg.com/@dashevo/wallet-lib\"></script>","title":"CDN Standalone"},{"location":"Wallet-library/#usage","text":"In your file, where you want to execute it : const { Wallet, EVENTS } = require('@dashevo/wallet-lib'); const wallet = new Wallet(); // We can dump our initialization parameters const mnemonic = wallet.exportWallet(); wallet.getAccount().then((account) => { // At this point, account has fetch all UTXOs if they exists const balance = account.getTotalBalance(); console.log(`Balance: ${balance}`); // We easily can get a new address to fund const { address } = account.getUnusedAddress(); });","title":"Usage"},{"location":"Wallet-library/#licence","text":"MIT \u00a9 Dash Core Group, Inc.","title":"Licence"},{"location":"Wallet-library/Overview/","text":"Getting started Quick start Quick introduction to core concepts Usage DAPI Examples Coin Selection Account new Account() .broadcastTransaction() .connect() .createTransaction() .decode() .decrypt() .disconnect() .encode() .encrypt() .fetchAddressInfo() .fetchStatus() .fetchTransactionInfo() .forceRefreshAccount() .generateAddress() .getAddress() .getConfirmedBalance() .getPrivateKeys() .getTotalBalance() .getTransaction() .getTransactionHistory() .getTransactions() .getUnconfirmedBalance() .getUTXOS() .sign() Wallet new Wallet() .createAccount() .disconnect() .exportWallet() .fromHDPrivateKey() .fromHDPublicKey() .fromMnemonic() .fromPrivateKey() .fromSeed() .generateNewWalletId() .getAccount() .dumpStorage() Identities new Identities() .getIdentityHDKeyByIndex() KeyChain new KeyChain() .generateKeyForChild() .generateKeyForPath() .getDIPExtendedKey() .getHardenedBIP44HDKey() .getHardenedDIP9FeatureHDKey() .getHardenedDIP15AccountKey() .getKeyForChild() .getKeyForPath() .getPrivateKey() .sign() Storage new KeyChain() .addNewTxToAddress() .addUTXOToAddress() .announce() .calculateDuffBalance() .clearAll() .configure() .createChain() .createWallet() .getStore() .getTransaction() .getTransactionMetadata() .importTransaction() .importTransactions() .rehydrateState() .saveState() .searchAddress() .searchAddressesWithTx() .searchBlockHeader() .searchTransaction() .searchTransactionMetadata() .searchWallet() .startWorker() .stopWorker() .stopWorker() .updateTransaction() Utils calculateTransactionFees() categorizeTransactions() classifyAddresses() coinSelection() dashToDuffs() duffsToDash() extendTransactionsWithMetadata() filterTransactions() getBytesOf() Mnemonic generateNewMnemonic() mnemonicToHDPrivateKey() mnemonicToSeed() mnemonicToWalletId() seedToHDPrivateKey() Events FETCHED/UNCONFIRMED_TRANSACTION FETCHED/CONFIRMED_TRANSACTION CONFIRMED_BALANCE_CHANGED UNCONFIRMED_BALANCE_CHANGED BLOCKHEIGHT_CHANGED Plugins Using a plugin Writing a new plugin Wallet workers Community plugins Develop Logging Persistence License","title":"Overview"},{"location":"Wallet-library/account/Account/","text":"Usage : new Account(wallet, accountOpts) Description : This method creates a new Account associated to the given wallet. Notes : As it is directly linked to a wallet, you might want to rely on Wallet.getAccount({index}) instead. When wallet.offlineMode:true , you can manage utxos / addresses via a cache options (or after init via the Storage controller). Parameters: parameters type required Description wallet Wallet yes A valid wallet instance accountOpts.index number no The BIP44 account index; by default use the next one (n+1) of the biggest account index already created in wallet accountOpts.strategy string/function no A valid strategy string identifier (amongst \"simpleAscendingAccumulator\", \"simpleDescendingAccumulator\", simpleTransactionOptimizedAccumulator\") or your own strategy function accountOpts.label string no (def: null) If you want to be able to reference to an account per label accountOpts.injectDefaultPlugins boolean no (def: true) Use to inject default plugins on loadup (BIP44Worker, ChainWorker and SyncWorker) accountOpts.allowSensitiveOperations boolean no (def: false) If you want a special plugin to access the keychain or other sensitive operation, set this to true. accountOpts.cacheTx boolean no (def: true) If you want to cache the transaction internally (for faster sync-up) accountOpts.cache.addresses object no If you have your addresses state somewhere else (fs) you can fetch and pass it along for faster sync-up accountOpts.cache.transactions object no If you have your tx state somewhere else (fs) you can fetch and pass it along for faster sync-up Returns : Account instance. Examples (assuming a Wallet instance created) : const { Account, Wallet } = require('@dashevo/wallet-lib'); const wallet = new Wallet(); const account = new Account(wallet, {index: 42}); await account.init(); Reminder : Because many parameters are inherited from the wallet object (network, plugins, transporter, storage, keychain...), initializing an Account without a Wallet will require mocking all those properties. Identities : Identities are accessible from an account via the identities interface : account.identities . See Identities","title":"Account"},{"location":"Wallet-library/account/broadcastTransaction/","text":"Usage : account.broadcastTransaction(transaction) Description : Allow to broadcast a valid signed transaction to the network. Notes : Requires a signed transaction, use account.sign(transaction) for that. Parameters: parameters type required Description transaction Transaction/String yes A valid created transaction or it's hexadecimal raw representation options Object no options.skipFeeValidation Boolean no When set to true, and min relay fee is not met, will still try to broadcast a transaction options.mempoolPropagationTimeout Number no The amount of milliseconds to wait for transaction mempool propagation Returns : transactionId (string). N.B : The TransactionID provided is subject to transaction malleability , and is not a source of truth (the transaction might be included in a block with a different txid).","title":"broadcastTransaction"},{"location":"Wallet-library/account/connect/","text":"Usage : account.connect() Description : This method can be used to reconnect after having used .disconnect() . It will connect to all streams, bloomfilters and will start workers. Parameters: parameters type required Description Returns : Boolean (true).","title":"Connect"},{"location":"Wallet-library/account/createTransaction/","text":"Usage : account.createTransaction(txOpts) Description : Allow to create a transaction to one or multiple recipients. Parameters: parameters type required Description txOpts.recipient string yes (if no recipients ) The external address recipient of this transaction txOpts.satoshis string yes (if no recipients set) The value amount to transfer to the recipient address txOpts.recipients Array[{recipient, satoshis}] no Alternatively, you can use this to send to multiple address/amount. Array arra of {recipient, satoshis} txOpts.utxos Array[utxos] no Can be specified to use specific utxo to use, or other utxos own by other private keys (you will need to pass the privateKeys along txOpts.privateKeys Array[PrivateKey/HDPrivateKey] no Overwrite the default behaviour (searching locally for keys) and uses these to sign instead. txOpts.strategy string/Function no Overwrite the default strategy used (using account default or specified strategy) txOpts.deductFee boolean no Defaults: true. When set at false, will not deduct fee on the Transaction object txOpts.change string no Defaults: account.getUnusedAddress(internal) . When set, will use that address as a change address on remaining fund Returns : Transaction Notes: This transaction will be need to be signed account.sign(transaction) and then, if wanted, broadcasted to the network for execution account.broadcastTransaction() . Example : const recipients = [{recipient:\"yereyozxENB9jbhqpbg1coE5c39ExqLSaG\", satoshis:10e8},{recipient: \"yMN2w8NiwcmY3zvJLeeBxpaExFV1aN23pg\", satoshis: 1e8}]; const change = \"yaVrJ5dgELFkYwv6AydDyGPAJQ5kTJXyAN\"; const tx = account.createTransaction({recipients, change}); Strategy: By default, wallet-lib is shipped with two different strategies : simpleDescendingStrategy : Will maximize the use of big inputs to meet the amount required. Allows the fee to be optimized for the smallest size at the cost of breaking big inputs. simpleAscendingStrategy : Will try to use as many small inputs as possible to meet the amount required. Allows using many small inputs at the cost of a potentially bigger fee. You can also pass your own strategy (as a function) to allow you to create your own strategy for how you will want to spend the UTXO. const recipient = \"yereyozxENB9jbhqpbg1coE5c39ExqLSaG\"; const satoshis = 10e8; const specialStrategy = (utxosList, outputsList, deductFee = false, feeCategory = 'normal')=> { //... }; const txOpts1 = { recipient, satoshis, strategy: 'simpleAscendingStrategy', }; const txOpts2 = { recipient, satoshis, strategy: specialStrategy, }; const tx1 = account.createTransaction(txOpts1); const tx2 = account.createTransaction(txOpts2); See more information about coinSelection . Deduct Fee In order to broadcast a transaction, a minimal relay fee is required for a node to accept to broadcast the transaction. Such fee are used as a spam mechanism protection as a standard transaction would require slightly more than 0.0000012 Dash (varies per transaction and per node) as relay fee. The deduct fee property, when set at true allows to automatically estimate the size and deduct from outputs the corresponding amount. In case one user would want to not see that, he will be required to select an input to pay a fee by himself. Expected minimal relay fee for your transaction can be estimated this way : const { storage, network } = account; const { chains } = storage.getStore(); const txOpts = { deductFee: false, } const transaction = account.createTransaction(txOpts); const { minRelay: minRelayFeeRate } = chains[network.toString()].fees; const estimateKbSize = transaction._estimateSize() / 1000; const minFeeToPay = estimateKbSize * minRelayFeeRate;","title":"createTransaction"},{"location":"Wallet-library/account/createTransaction/#deduct-fee","text":"In order to broadcast a transaction, a minimal relay fee is required for a node to accept to broadcast the transaction. Such fee are used as a spam mechanism protection as a standard transaction would require slightly more than 0.0000012 Dash (varies per transaction and per node) as relay fee. The deduct fee property, when set at true allows to automatically estimate the size and deduct from outputs the corresponding amount. In case one user would want to not see that, he will be required to select an input to pay a fee by himself. Expected minimal relay fee for your transaction can be estimated this way : const { storage, network } = account; const { chains } = storage.getStore(); const txOpts = { deductFee: false, } const transaction = account.createTransaction(txOpts); const { minRelay: minRelayFeeRate } = chains[network.toString()].fees; const estimateKbSize = transaction._estimateSize() / 1000; const minFeeToPay = estimateKbSize * minRelayFeeRate;","title":"Deduct Fee"},{"location":"Wallet-library/account/decode/","text":"Usage : account.decode(method, encodedValue) Description : Allow to decode an encoded value. Notes : Method allowed right now limited to cbor (used by platform protocol). Parameters: parameters type required Description method String yes Enter a valid decoding method (one of: ['cbor']) encodedValue Buffer yes An encoded buffer value Returns : decoded value (string).","title":"Decode"},{"location":"Wallet-library/account/decrypt/","text":"Usage : account.decrypt(method, encryptedData, secret, encoding) Description : Allow to decrypt an encrypted message Parameters: parameters type required Description method String yes Enter a valid decrypt method (one of: ['aes']) encryptedData String yes An encrypted value secret String yes The secret used for encrypting the data in first place encoding ['hex','utf8'] no (def: utf8) The secret used for encrypting the data in first place Returns : decoded value (string). const decrypted = account.decrypt('aes','U2FsdGVkX18+7ixRbZ7DzC8P8X/4ewNHSp2R6pZDmsI=', 'secret') console.log(decrypted);// coucou","title":"Decrypt"},{"location":"Wallet-library/account/disconnect/","text":"Usage : account.disconnect() Description : This method will disconnect all plugins and other workers (Storage, SyncWorker). Useful to release all worker when doing integration testing with Wallet/Account Parameters: parameters type required Description Returns : void.","title":"Disconnect"},{"location":"Wallet-library/account/encode/","text":"Usage : account.encode(method, data) Description : Allow to encode any raw data Notes : Methods allowed right now limited to cbor (used by platform protocol). Parameters: parameters type required Description method String yes Enter a valid encoding method (one of: ['cbor']) data Object/String yes A value to encode Returns : encoded value (Buffer) Example : const jsonObject = { string: 'string', list: ['a', 'b', 'c', 'd'], obj: { int: 1, boolean: true, theNull: null, }, }; const encodedJSON = account.encode('cbor', jsonObject) console.log(Buffer.from(encodedJSON).toString('hex'));","title":"Encode"},{"location":"Wallet-library/account/encrypt/","text":"Usage : account.encrypt(method, data, secret) Description : Allow to encrypt a value using a specific secret Parameters: parameters type required Description method String yes Enter a valid encryption method (one of: ['aes']) data String yes The value to encrypt secret String yes The secret used in order to encrypt the data Returns : encrypted value (string). ```js const encrypted = account.encrypt('aes','coucou', 'secret'); console.log(encrypted);// U2FsdGVkX18+7ixRbZ7DzC8P8X/4ewNHSp2R6pZDmsI=","title":"Encrypt"},{"location":"Wallet-library/account/fetchAddressInfo/","text":"Usage : account.fetchAddressInfo(addressObj, fetchUtxo) Description : Fetch a specific address from the transport layer Notes : This method will have breaking changes with SPV implementation. We encourage you with using Storage or DAPI-Client . Parameters: parameters type required Description addressObj String yes Enter a valid encryption method (one of: ['aes']) fetchUtxo String yes The value to encrypt (default: true) Returns : addrInfo (object representation of an address metadata) N.B: An AddressObject is an intern representation consisting of a {path, address, index}","title":"fetchAddressInfo"},{"location":"Wallet-library/account/fetchStatus/","text":"Usage : account.fetchStatus() Description : Allow to retrieve status of the current chain (blockheight). Parameters: parameters type required Description Returns : status object","title":"fetchStatus"},{"location":"Wallet-library/account/fetchTransactionInfo/","text":"Usage : account.fetchTransactionInfo() Description : Fetch a specific transaction from the transport layer Notes : This method will have breaking changes with SPV implementation. We encourage you with using Storage or DAPI-Client . Parameters: parameters type required Description transactionId String yes identifier of the Transaction to retrieve Returns : transaction object (metadata : txid, blockhash, blockheight, blocktime, fees, size, vout, vin, txlock ).","title":"fetchTransactionInfo"},{"location":"Wallet-library/account/forceRefreshAccount/","text":"Usage : account.forceRefreshAccount() Description : Force a refresh of all the addresses informations (utxo, balance, txs...) by invalidating previous. Important : This is used for experience developer. If you have an issue or need using it, please do not hesitate to post an issue on GitHub. Parameters: parameters type required Description Returns : boolean.","title":"forceRefreshAccount"},{"location":"Wallet-library/account/generateAddress/","text":"Usage : account.generateAddress(path) Description : Generate an address from a path and import it to the store Notes : Usage of generate is discouraged, used account.getAddress() instead. Parameters: parameters type required Description path String yes BIP44 path of the address to generate Returns : address object (metadata : path, index, address, transactions, balanceSat, unconfirmedBalanceSat, utxos, fetchedLast, used ).","title":"generateAddress"},{"location":"Wallet-library/account/getAddress/","text":"Usage : account.getAddress(index, type) Description : Get a specific address based on the index and type of address. Parameters: parameters type required Description index number no Index of the address (starting at 0) - default:0 type String no Type of the address, one of ['external','internal','misc']. - default: external Returns : address object (metadata : path, index, address, transactions, balanceSat, unconfirmedBalanceSat, utxos, fetchedLast, used ).","title":"getAddress"},{"location":"Wallet-library/account/getConfirmedBalance/","text":"Usage : account.getConfirmedBalance(displayDuffs) Description : This method will return the confirmed balance (included in a block) of an account Parameters: parameters type required Description displayDuffs boolean no (default: true) When set at true return in Duffs (satoshis), if false, returns in Dash Return : number","title":"getConfirmedBalance"},{"location":"Wallet-library/account/getPrivateKeys/","text":"Usage : account.getPrivateKeys(addressList) Description : This method return the private keys list matching the passed address list of public keys Parameters: parameters type required Description addressList Array[String ] yes The list of public address to match private key Returns : Array[PrivateKey]","title":"getPrivateKeys"},{"location":"Wallet-library/account/getTotalBalance/","text":"Usage : account.getTotalBalance(displayDuffs) Description : This method will return the total (unconfirmed + confirmed) balance of an account Parameters: parameters type required Description displayDuffs boolean no (default: true) When set at true return in Duffs (satoshis), if false, returns in Dash Return : number","title":"getTotalBalance"},{"location":"Wallet-library/account/getTransaction/","text":"Usage : account.getTransaction(txid) Description : This method will return the transaction of a specific id Parameters: parameters type required Description txid string yes TxId of the transaction to fetch. Return : transaction with metadata account.getTransaction('1a74dc225b3336c4edb1f94c9ec2ed88fd0ef136866fda26f8a734924407b4d6'); /* returns : { transaction: Transaction, metadata: { blockHash: '0000007a84abfe1d2b4201f4844bb1e59f24daf965c928281589269f281abc01', height: 551438, instantLocked: true, chainLocked: true } } */","title":"getTransaction"},{"location":"Wallet-library/account/getTransactionHistory/","text":"Usage : account.getTransactionHistory() Description : Allow to get the transaction history of an account Parameters: parameters type required Description Returns : sorted and classified transaction history const transactionHistory = await account.getTransactionHistory(); Results in [{ from: [ { address: 'yNCqctyQaq51WU1hN5aNwsgMsZ5fRiB7GY', addressType: 'external' } ], to: [ { address: 'yiXh4Yo5djG6QH8WzXkKm5EFzqLRJWakXz', satoshis: 1150000000, addressType: 'otherAccount' }, { address: 'yh6Hcyipdvp6WJpQxjNbaXP4kzPQUJpY3n', satoshis: 49999753, addressType: 'internal' } ], type: 'account_transfer', time: Date('2021-08-17T21:35:58.000Z'), txId: '6f76ca8038c6cb1b373bbbf80698afdc0d638e4a223be12a4feb5fd8e1801135', blockHash: '000000444b3f2f02085f8befe72da5442c865c290658766cf935e1a71a4f4ba7', isChainLocked: true, isInstantLocked: true, satoshisBalanceImpact: -1150000000, feeImpact: 247 }] Where addressType=external|internal|otherAccount|unknown","title":"getTransactionHistory"},{"location":"Wallet-library/account/getTransactions/","text":"Usage : account.getTransactions() Description : This method will return the transactions for this account Parameters: parameters type required Description Returns : Array[transaction].","title":"getTransactions"},{"location":"Wallet-library/account/getUTXOS/","text":"Usage : account.getUTXOS(options) Description : This method will return the list of all available UTXOS for this account. Parameters: parameters type required Description options.coinbaseMaturity Number no (def: 100) Allow to override coinbase maturity Returns : Array[utxos].","title":"getUTXOS"},{"location":"Wallet-library/account/getUnconfirmedBalance/","text":"Usage : account.getUnconfirmedBalance(displayDuffs) Description : This method will return the unconfirmed balance (missing inclusion in a block) of an account Parameters: parameters type required Description displayDuffs boolean no (default: true) When set at true return in Duffs (satoshis), if false, returns in Dash Return : number","title":"getUnconfirmedBalance"},{"location":"Wallet-library/account/sign/","text":"Usage : account.sign(transaction, privateKeys, sigType) Description : Allow to sign a transaction with private keys Notes : A Signable Object is of type : Transaction or Message (exported by DashJS). Parameters: parameters type required Description object Signable yes Enter a valid encryption method (one of: ['aes']) privateKeys PrivateKey yes The private keys used to sign sigtype String no Default: crypto.Signature.SIGHASH_ALL Returns : Signed Signable Object. Examples Signing a transaction const tx = account.createTransaction(); const signedTx = account.sign(tx); // Will find the privateKey from keychain for you. Signing a message const {Message} = require('dash'); const message = new Message('hello, world'); const idPrivateKey = account.getIdentityHDKeyByIndex(0, 0).privateKey; const signed = account.sign(message, idPrivateKey); const verify = message.verify(idPrivateKey.toAddress().toString(), signed.toString()); // true","title":"Sign"},{"location":"Wallet-library/account/sign/#examples","text":"","title":"Examples"},{"location":"Wallet-library/account/sign/#signing-a-transaction","text":"const tx = account.createTransaction(); const signedTx = account.sign(tx); // Will find the privateKey from keychain for you.","title":"Signing a transaction"},{"location":"Wallet-library/account/sign/#signing-a-message","text":"const {Message} = require('dash'); const message = new Message('hello, world'); const idPrivateKey = account.getIdentityHDKeyByIndex(0, 0).privateKey; const signed = account.sign(message, idPrivateKey); const verify = message.verify(idPrivateKey.toAddress().toString(), signed.toString()); // true","title":"Signing a message"},{"location":"Wallet-library/develop/logging/","text":"Logging Wallet-lib will log multiple events happening which might help you to debug, or get a better understanding at what is happening internally. Log levels These are the different levels used internally sorted from the least verbose to the most. error - Warn about issues that are near critical (but are not straight thrown errors). warn - Warn about issues that aren't so critical. info - Log level used by default. Inform about some internal high value steps. debug - Inform about basic steps (plugin initialisations, ...) silly - Inform about everything going on (each transporter call, storage and worker execution,...) Set a log level In order to control the granularity of the logger, simply put the environment variable LOG_LEVEL at the desired level. Windows: set LOG_LEVEL=silly node index.js MacOS: LOG_LEVEL=silly node index.js Linux: export LOG_LEVEL=silly node index.js","title":"Logging"},{"location":"Wallet-library/develop/logging/#logging","text":"Wallet-lib will log multiple events happening which might help you to debug, or get a better understanding at what is happening internally.","title":"Logging"},{"location":"Wallet-library/develop/logging/#log-levels","text":"These are the different levels used internally sorted from the least verbose to the most. error - Warn about issues that are near critical (but are not straight thrown errors). warn - Warn about issues that aren't so critical. info - Log level used by default. Inform about some internal high value steps. debug - Inform about basic steps (plugin initialisations, ...) silly - Inform about everything going on (each transporter call, storage and worker execution,...)","title":"Log levels"},{"location":"Wallet-library/develop/logging/#set-a-log-level","text":"In order to control the granularity of the logger, simply put the environment variable LOG_LEVEL at the desired level. Windows: set LOG_LEVEL=silly node index.js MacOS: LOG_LEVEL=silly node index.js Linux: export LOG_LEVEL=silly node index.js","title":"Set a log level"},{"location":"Wallet-library/develop/persistence/","text":"Persistence Wallet-lib allows the use of a persistence adapter in order to store information fetched via the transporter in order to provide faster loading on later uses. This adapter can be useful for multiple cases, for instance: A degraded connectivity: Having stored information on a persistence layer (localStorage, secureStorage,...) would allow a user to still be able to consult his transaction history, UTXO set, balance, prepare and sign a transaction (intended to be broadcasted later, when connectivity is back). Offline Mode: In some conditions, using the wallet-lib on a non-connected device might be a desired feature. The persistence adapter would allow such usage be still providing most of it's feature from it's cache, and therefore, in the example of a transaction signing, the signing would be done on the offline device, while the broadcast would happen on another, connected device. When no persistence is set, Wallet-lib will use by default, an In Memory adapter, which won't persist information except in local RAM. A message will warn you about this on starting up, and won't be displayed with a properly set adapter. Create your own persistence adapter By just providing a class or instance of a class containing a certain minimal set of methods, one can provide an adapter for various databases, remote services or file storage. config(props) - async / optional - When provided, before any execution, this method would be called passing with the following property name: 'dashevo-wallet-lib' . This method intends to allow the preparation of your persistence layer to be ready for further uses (for instance, in a case where your adapter is a database, this would allow to set indexes, and prepare the connection pool). setItem(key, item) - async / mandatory - This is the method that will be used to set any item to the persistence layer. getItem(key) - async / mandatory - This will be called in order to retrieve any item from the persistence layer.","title":"Persistence"},{"location":"Wallet-library/develop/persistence/#persistence","text":"Wallet-lib allows the use of a persistence adapter in order to store information fetched via the transporter in order to provide faster loading on later uses. This adapter can be useful for multiple cases, for instance: A degraded connectivity: Having stored information on a persistence layer (localStorage, secureStorage,...) would allow a user to still be able to consult his transaction history, UTXO set, balance, prepare and sign a transaction (intended to be broadcasted later, when connectivity is back). Offline Mode: In some conditions, using the wallet-lib on a non-connected device might be a desired feature. The persistence adapter would allow such usage be still providing most of it's feature from it's cache, and therefore, in the example of a transaction signing, the signing would be done on the offline device, while the broadcast would happen on another, connected device. When no persistence is set, Wallet-lib will use by default, an In Memory adapter, which won't persist information except in local RAM. A message will warn you about this on starting up, and won't be displayed with a properly set adapter.","title":"Persistence"},{"location":"Wallet-library/develop/persistence/#create-your-own-persistence-adapter","text":"By just providing a class or instance of a class containing a certain minimal set of methods, one can provide an adapter for various databases, remote services or file storage. config(props) - async / optional - When provided, before any execution, this method would be called passing with the following property name: 'dashevo-wallet-lib' . This method intends to allow the preparation of your persistence layer to be ready for further uses (for instance, in a case where your adapter is a database, this would allow to set indexes, and prepare the connection pool). setItem(key, item) - async / mandatory - This is the method that will be used to set any item to the persistence layer. getItem(key) - async / mandatory - This will be called in order to retrieve any item from the persistence layer.","title":"Create your own persistence adapter"},{"location":"Wallet-library/events/blockheight_changed/","text":"Usage : account.events.on('blockheight_changed', fn) Description : An event is thrown each time Wallet-lib is being made aware of a new block validated by the protocol. Example: const {EVENTS} = require('@dashevo/wallet-lib'); account.events.on(EVENTS.BLOCKHEIGHT_CHANGED, ({payload: blockHeight})=>{ console.log(`Blockheight changed to ${blockHeight}`); });","title":"Blockheight changed"},{"location":"Wallet-library/events/confirmed_balance_changed/","text":"Usage : account.events.on('confirmed_balance_changed', fn) Description : Wallet-lib, when finished to perform it's internal tasks (blockheight, SPV, utxos sync...), will throw this event. Important : Standardization on event might happen soon, to avoid breaking change, use the EVENTS constant as described below. Example: const {EVENTS} = require('@dashevo/wallet-lib'); const onConfirmedBalanceChange = ()=>{ console.log('Balance changed'); } account.events.on(EVENTS.CONFIRMED_BALANCE_CHANGED, onConfirmedBalanceChange);","title":"Confirmed balance changed"},{"location":"Wallet-library/events/fetched_confirmed_transaction/","text":"Usage : account.events.on('FETCHED/CONFIRMED_TRANSACTION', fn) Description : Every time a new confirmed transaction is fetched from the network, an event in thrown. Returns : {Transaction} Example: const {EVENTS} = require('@dashevo/wallet-lib'); const onNewConfirmedTx = (tx)=>{ console.log('Confirmed tx', tx); } account.events.on(EVENTS.FETCHED_CONFIRMED_TRANSACTION, onNewConfirmedTx);","title":"Fetched confirmed transaction"},{"location":"Wallet-library/events/fetched_unconfirmed_transaction/","text":"Usage : account.events.on('FETCHED/UNCONFIRMED_TRANSACTION', fn) Description : Every time a new unconfirmed transaction is fetched from the network, an event in thrown. Returns : {Transaction} Example: const {EVENTS} = require('@dashevo/wallet-lib'); const onNewUnconfirmedTx = (tx)=>{ console.log('Unconfirmed tx', tx); } account.events.on(EVENTS.FETCHED_UNCONFIRMED_TRANSACTION, onNewUnconfirmedTx);","title":"Fetched unconfirmed transaction"},{"location":"Wallet-library/events/ready/","text":"Usage : account.events.on('ready', fn) Description : Wallet-lib, when finished to perform it's internal tasks (blockheight, SPV, utxos sync...), will throw this event. Example: const {EVENTS} = require('@dashevo/wallet-lib'); const onReady = ()=>{ console.log('Wallet-lib is ready to perform action'); } account.events.on(EVENTS.READY, onReady);","title":"Ready"},{"location":"Wallet-library/events/unconfirmed_balance_changed/","text":"Usage : account.events.on('unconfirmed_balance_changed', fn) Description : When not offline, the wallet will keep track of new transaction incoming or outgoing, these cause balance modification that this method warn about Important : Standardization on event might happen soon, to avoid breaking change, use the EVENTS constant as described below. Example: const {EVENTS} = require('@dashevo/wallet-lib'); const onUnconfirmedBalanceChange = ()=>{ console.log('Unconfirmed Balance changed'); } account.events.on(EVENTS.UNCONFIRMED_BALANCE_CHANGED, onUnconfirmedBalanceChange);","title":"Unconfirmed balance changed"},{"location":"Wallet-library/getting-started/core-concepts/","text":"Core concepts The Dash Core Developer Guide will answer most of the questions about the fundamentals of Dash. However, some elements provided by the SDK need to be grasped, so we will quickly cover some of those. Wallet At the core of Dash is the Payment Chain, in order to be able to transact on it, one needs to have a set of UTXO that is controlled by a Wallet instance. In order to access your UTXO, you will have to provide a valid mnemonic that will unlock the Wallet and automatically fetch the associated UTXOs. Wallet accounts Since the introduction of deterministic wallet , a Wallet is actually composed of multiple account. For manipulating multiple accounts, Wallet.getAccount() takes optional options where index allows either accessing or creating a specific account index. Instantiation types A Wallet instance can be created from multiples types, which impact how much the Wallet can do. In general, we expect you to initialize from a mnemonic or an seed (HD seed) or an HDPrivateKey , which allows wallet-lib to deal with HD Wallet (deterministic wallet). In some other cases, you might want to instantiate Wallet from another input such as : - privateKey : This allows managing a single privateKey/publicKey set. Therefore, you will only have a single unique address to receive money. - HDPublicKey : This allows a \"watch-only\" mode. You won't be able to spend anything, but this will allow you to track and monitor in real-time the address set of this public key. This allows you to derive unique unused addresses from a single key (shared by another user, third-party merchant). Learn more about instantiation documentation","title":"Core concepts"},{"location":"Wallet-library/getting-started/core-concepts/#core-concepts","text":"The Dash Core Developer Guide will answer most of the questions about the fundamentals of Dash. However, some elements provided by the SDK need to be grasped, so we will quickly cover some of those.","title":"Core concepts"},{"location":"Wallet-library/getting-started/core-concepts/#wallet","text":"At the core of Dash is the Payment Chain, in order to be able to transact on it, one needs to have a set of UTXO that is controlled by a Wallet instance. In order to access your UTXO, you will have to provide a valid mnemonic that will unlock the Wallet and automatically fetch the associated UTXOs.","title":"Wallet"},{"location":"Wallet-library/getting-started/core-concepts/#wallet-accounts","text":"Since the introduction of deterministic wallet , a Wallet is actually composed of multiple account. For manipulating multiple accounts, Wallet.getAccount() takes optional options where index allows either accessing or creating a specific account index.","title":"Wallet accounts"},{"location":"Wallet-library/getting-started/core-concepts/#instantiation-types","text":"A Wallet instance can be created from multiples types, which impact how much the Wallet can do. In general, we expect you to initialize from a mnemonic or an seed (HD seed) or an HDPrivateKey , which allows wallet-lib to deal with HD Wallet (deterministic wallet). In some other cases, you might want to instantiate Wallet from another input such as : - privateKey : This allows managing a single privateKey/publicKey set. Therefore, you will only have a single unique address to receive money. - HDPublicKey : This allows a \"watch-only\" mode. You won't be able to spend anything, but this will allow you to track and monitor in real-time the address set of this public key. This allows you to derive unique unused addresses from a single key (shared by another user, third-party merchant). Learn more about instantiation documentation","title":"Instantiation types"},{"location":"Wallet-library/getting-started/quickstart/","text":"Quick start ES5/ES6 via NPM In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/wallet-lib CDN Standalone For browser usage, you can also directly rely on unpkg for wallet-lib, and localForage as adapter for persistence. <script src=\"https://unpkg.com/@dashevo/wallet-lib\"></script> <script src=\"https://unpkg.com/localforage\"></script> <script> const { Wallet } = require('@dashevo/wallet-lib'); const wallet = new Wallet({adapter: localforage}); </script> Initialization Let's load our Wallet by creating a new Wallet instance specifying our mnemonic. const { Wallet } = require('@dashevo/wallet-lib'); const opts = { network: 'testnet', mnemonic: \"arena light cheap control apple buffalo indicate rare motor valid accident isolate\", }; const wallet = new Wallet(opts); wallet.getAccount().then((account) => { // At this point, account has fetched all UTXOs if they exist const balance = account.getTotalBalance(); console.log(`Balance: ${balance}`); // We easily can get a new address to fund const { address } = account.getUnusedAddress(); }); In above code, we did not specify any transport instance, as by default, wallet-lib is using DAPI as a transporter; The adapter not being set, we will use by default an in-memory (without persistence) adapter. One can set any adapter that contains a valid adapter syntax (getItem, setItem), such as localForage , you can learn more about creating your own persistence adapter . Quick note : If no mnemonic is provided (nor any privatekey, HDPubKey,...), or if mnemonic is null , a mnemonic will be created for you automatically. By default, if not provided, network value will be evonet . If no adapter specified, Wallet-lib will use an in-memory store (and warn you about it). If no transport specified, Wallet-lib will connect to DAPI. wallet.getAccount() is by default equivalent to wallet.getAccount({ index:0 }) , where 0 correspond of the account index as per BIP44 . Make a payment to an address const options = { recipient:'yLptqWxjgTxtwKJuLHoGY222NnoeqYuN8h', satoshis:100000 }; const transaction = account.createTransaction(options) Broadcast the transaction const txid = await account.broadcastTransaction(transaction); Some rules of thumb There are multiple event listeners (socket sync,...), running intervals (service worker,...), therefore a good way to quit an instance would be to call account.disconnect() which will care to call clearWorker(), closeSocket() of the different elements. You can still decide to remove them by hand if you want. Some classic examples of usage can be seen here : Examples","title":"Quick start"},{"location":"Wallet-library/getting-started/quickstart/#quick-start","text":"","title":"Quick start"},{"location":"Wallet-library/getting-started/quickstart/#es5es6-via-npm","text":"In order to use this library in Node, you will need to add it to your project as a dependency. Having NodeJS installed, just type in your terminal : npm install @dashevo/wallet-lib","title":"ES5/ES6 via NPM"},{"location":"Wallet-library/getting-started/quickstart/#cdn-standalone","text":"For browser usage, you can also directly rely on unpkg for wallet-lib, and localForage as adapter for persistence. <script src=\"https://unpkg.com/@dashevo/wallet-lib\"></script> <script src=\"https://unpkg.com/localforage\"></script> <script> const { Wallet } = require('@dashevo/wallet-lib'); const wallet = new Wallet({adapter: localforage}); </script>","title":"CDN Standalone"},{"location":"Wallet-library/getting-started/quickstart/#initialization","text":"Let's load our Wallet by creating a new Wallet instance specifying our mnemonic. const { Wallet } = require('@dashevo/wallet-lib'); const opts = { network: 'testnet', mnemonic: \"arena light cheap control apple buffalo indicate rare motor valid accident isolate\", }; const wallet = new Wallet(opts); wallet.getAccount().then((account) => { // At this point, account has fetched all UTXOs if they exist const balance = account.getTotalBalance(); console.log(`Balance: ${balance}`); // We easily can get a new address to fund const { address } = account.getUnusedAddress(); }); In above code, we did not specify any transport instance, as by default, wallet-lib is using DAPI as a transporter; The adapter not being set, we will use by default an in-memory (without persistence) adapter. One can set any adapter that contains a valid adapter syntax (getItem, setItem), such as localForage , you can learn more about creating your own persistence adapter . Quick note : If no mnemonic is provided (nor any privatekey, HDPubKey,...), or if mnemonic is null , a mnemonic will be created for you automatically. By default, if not provided, network value will be evonet . If no adapter specified, Wallet-lib will use an in-memory store (and warn you about it). If no transport specified, Wallet-lib will connect to DAPI. wallet.getAccount() is by default equivalent to wallet.getAccount({ index:0 }) , where 0 correspond of the account index as per BIP44 .","title":"Initialization"},{"location":"Wallet-library/getting-started/quickstart/#make-a-payment-to-an-address","text":"const options = { recipient:'yLptqWxjgTxtwKJuLHoGY222NnoeqYuN8h', satoshis:100000 }; const transaction = account.createTransaction(options)","title":"Make a payment to an address"},{"location":"Wallet-library/getting-started/quickstart/#broadcast-the-transaction","text":"const txid = await account.broadcastTransaction(transaction);","title":"Broadcast the transaction"},{"location":"Wallet-library/getting-started/quickstart/#some-rules-of-thumb","text":"There are multiple event listeners (socket sync,...), running intervals (service worker,...), therefore a good way to quit an instance would be to call account.disconnect() which will care to call clearWorker(), closeSocket() of the different elements. You can still decide to remove them by hand if you want. Some classic examples of usage can be seen here : Examples","title":"Some rules of thumb"},{"location":"Wallet-library/identities/Identities/","text":"Usage : new Identities(wallet) Description : This method creates a new Identities instance associated to the given wallet. Parameters: parameters type required Description wallet Wallet yes A valid wallet instance Returns : Identities instance. Examples (assuming a Wallet instance created) : const { Identities, Wallet } = require('@dashevo/wallet-lib'); const wallet = new Wallet(); const identities = new Identities(wallet); identities.getIdentityHDKeyByIndex(0, 0);","title":"Identities"},{"location":"Wallet-library/identities/getIdentityHDKeyByIndex/","text":"Usage : identities.getIdentityHDKeyByIndex(identityIndex, keyIndex) Description : This method returns the identity HDKey of identityIndex for the specified keyIndex Parameters: parameters type required Description identityIndex number yes To derive the key for a specific identityIndex (default: 0) keyIndex number yes To derive the key for a specific keyIndex (default: 0) Returns : HDKeys (private, public).","title":"getIdentityHDKeyByIndex"},{"location":"Wallet-library/keychain/KeyChain/","text":"Usage : new KeyChain(opts) Description : This method create a new KeyChain. Which handle handle the derivation and handling of the HDRootKey (when init from an HDPrivKey). While both the seed and the mnemonic would allow to generate other coins private keys, a HDRootKey is specific to a coin, which is why it's the value used in store.. Parameters: parameters type required Description opts.network Network String no (testnet) opts.type string yes The type of the KeyChain (HDPrivateKey, HDPublicKey or privateKey) opts.HDPrivateKey object yes (if type) If type is HDPrivateKey, the root HDPrivateKey to allow KeyChain to generate new address opts.HDPublicKey object yes (if type) If type is HDPublicKey, the root HDPublicKey to allow KeyChain to generate new public address opts.privateKey object yes (if type) If type is a PrivateKey, the PrivKey to allow KeyChain to manage public address opts.keys object no If required, allow to create KeyChain by passing it a set of keys Returns : Keychain instance.","title":"KeyChain"},{"location":"Wallet-library/keychain/generateKeyForChild/","text":"Usage : keychain.generateKeyForChild(index,type) Description : Generate key for a specific index without storing the result in keychain. Important : For cache/perf reason, this method is discouraged in favor of getKeyForPath. Parameters: parameters type required Description index number yes Enter a valid index to derivate to type string no (default:HDPrivateKey) Enter a valid type (one of: ['HDPrivateKey','HDPublicKey']) Returns : {HDPrivateKey|HDPublicKey} Example: const { privateKey } = keychain.generateKeyForChild(0); VERIFY THAT IT ACTUALLY WORKS AS EXPECTED LOL.","title":"generateKeyForChild"},{"location":"Wallet-library/keychain/generateKeyForPath/","text":"Usage : keychain.generateKeyForPath(path, type) Description : Generate key for a specific path without storing the result in keychain. Important : For cache/perf reason, this method is discouraged in favor of getKeyForPath. Parameters: parameters type required Description path string yes Enter a valid path type string no (default:HDPrivateKey) Enter a valid type (one of: ['HDPrivateKey','HDPublicKey']) Returns : {HDPrivateKey|HDPublicKey} Example: const { privateKey } = keychain.generateKeyForPath(0); ADD TESTS! PLUS PATH","title":"generateKeyForPath"},{"location":"Wallet-library/keychain/getDIP15ExtendedKey/","text":"Usage : keychain.getDIP15ExtendedKey(userUniqueId, contactUniqueId, index, accountIndex = 0, type = 'HDPrivateKey') Description : Return a DIP15 Extended Key of a 2-contacts relationship Parameters: parameters type required Description userUniqueId string yes Current DashPay unique UserID contactUniqueId string yes Contact DashPay unique UserID index number no(=0) the key index to derivate to accountIndex number no(=0) the wallet account index from which to derivate type string no (default:HDPrivateKey) type of returned keys. one of: ['HDPrivateKey','HDPublicKey']. Returns : {HDPrivateKey|HDPublicKey} (of path: m/9'/5'/15'/accountIndex'/userId'/contactID'/index on mainnet or m/9'/1'/15'/... on testnet) Example: // m/9'/5'/15'/0'/0x555d3854c910b7dee436869c4724bed2fe0784e198b8a39f02bbb49d8ebcfc3a'/0xa137439f36d04a15474ff7423e4b904a14373fafb37a41db74c84f1dbb5c89b5'/0 const userUniqueId = '0x555d3854c910b7dee436869c4724bed2fe0784e198b8a39f02bbb49d8ebcfc3a'; const contactUniqueId = '0xa137439f36d04a15474ff7423e4b904a14373fafb37a41db74c84f1dbb5c89b5'; const DIP15ExtPrivKey_0 = keychain2.getDIP15ExtendedKey(userUniqueId, contactUniqueId, 0, 0, 'HDPrivateKey'); const { privateKey } = DIP15ExtPrivKey_0; //fac40790776d171ee1db90899b5eb2df2f7d2aaf35ad56f07ffb8ed2c57f8e60","title":"getDIP15ExtendedKey"},{"location":"Wallet-library/keychain/getHardenedBIP44HDKey/","text":"Usage : keychain.getHardenedBIP44HDKey(type) Description : Return a safier root key to derivate from Parameters: parameters type required Description type string no (default:HDPrivateKey) Enter a valid type (one of: ['HDPrivateKey','HDPublicKey']) Returns : HDPrivateKey Example: const hdPrivateKey = keychain.getHardenedBIP44HDKey(); const { privateKey } = hdPrivateKey","title":"getHardenedBIP44HDKey"},{"location":"Wallet-library/keychain/getHardenedDIP15AccountKey/","text":"Usage : keychain.getHardenedDIP15AccountKey(accountIndex = 0, type = 'HDPrivateKey') Description : Return a safier root path to derivate from Parameters: parameters type required Description accountIndex number no (default:0) set the account index type string no (default:HDPrivateKey) Enter a valid type (one of: ['HDPrivateKey','HDPublicKey']) Returns : HDPrivateKey (of path: m/9'/1'/15'/accountIndex' on testnet or m/9'/5'/15'/accountIndex' on livenet) Example: const hdPrivateKey = keychain.getHardenedDIP15AccountKey(); const { privateKey } = hdPrivateKey;","title":"getHardenedDIP15AccountKey"},{"location":"Wallet-library/keychain/getHardenedDIP9FeatureHDKey/","text":"Usage : keychain.getHardenedDIP9FeatureHDKey(type) Description : Return a safier root key to derivate from Parameters: parameters type required Description type string no (default:HDPrivateKey) Enter a valid type (one of: ['HDPrivateKey','HDPublicKey']) Returns : HDPrivateKey (of path: m/9'/1' on testnet or m/9'/5' on livenet) Example: const hdPrivateKey = keychain.getHardenedDIP9FeatureHDKey(); const { privateKey } = hdPrivateKey;","title":"getHardenedDIP9FeatureHDKey"},{"location":"Wallet-library/keychain/getKeyForChild/","text":"Usage : keychain.getKeyForChild(index,type) Description : Use to derivate the root key to a specific child. (useful when Wallet is initialized from a HDPublicKey) Parameters: parameters type required Description index number yes Enter a valid index type string no (default:HDPublicKey) Enter a valid type (one of: ['HDPrivateKey','HDPublicKey']) Returns : HDPrivateKey Example: const { privateKey } = keychain.getKeyForChild(0);","title":"getKeyForChild"},{"location":"Wallet-library/keychain/getKeyForPath/","text":"Usage : keychain.getKeyForPath(path,type) Description : Get a key from the keychain cache or generate if not yet existing Parameters: parameters type required Description path string yes Enter a valid derivation path type string no (default:HDPrivateKey) Enter a valid type (one of: ['HDPrivateKey','HDPublicKey']) Returns : HDPrivateKey Example: const { privateKey } = keychain.getKeyForPath(`m/44'/1'/0'/0'/0`);","title":"getKeyForPath"},{"location":"Wallet-library/keychain/getPrivateKey/","text":"Usage : keychain.getPrivateKey() Description : Return the privateKey of the HDPrivateKey of a KeyChain initialized from a mnemonic (alternatively, if Keychain is init from a pk, it just returns it.) Parameters: parameters type required Description Returns : PrivateKey","title":"getPrivateKey"},{"location":"Wallet-library/keychain/sign/","text":"Usage : keychain.sign(transaction, privateKeys, sigType) Description : Allow to sign a transaction with private keys Parameters: parameters type required Description object Transaction yes Enter a valid encryption method (one of: ['aes']) privateKeys PrivateKey yes The private keys used to sign sigtype String no Default: crypto.Signature.SIGHASH_ALL Returns : Signed Transaction.","title":"Sign"},{"location":"Wallet-library/plugins/community-plugins/","text":"Community plugins Submit your own plugin You may propose your own plugin by submitting a P.R to this file with the GitHub or NPM repository for your plugin with a small description.","title":"Community plugins"},{"location":"Wallet-library/plugins/community-plugins/#community-plugins","text":"","title":"Community plugins"},{"location":"Wallet-library/plugins/community-plugins/#submit-your-own-plugin","text":"You may propose your own plugin by submitting a P.R to this file with the GitHub or NPM repository for your plugin with a small description.","title":"Submit your own plugin"},{"location":"Wallet-library/plugins/using-a-plugin/","text":"Using a plugin About plugins In order to add features and logic to the Wallet-library and be able to share independant module and request them together. Wallet-lib can be passed some plugins at his instantiation. Plugins are particular shaped class that can perform action on your wallet. By default, three plugins are injected : BIP44Worker, SyncWorker and ChainWorker. They handle respectively with maintaining your address pool, getting you in sync with the blockchain and maintaining some knowledge about the chain (blockheight). You can disable them by adding injectDefaultPlugins:false at the initialization parameter of your wallet object. For more granularity, you could do it as a parameter of getAccount(accOpts) . Type of plugins There are three different types of plugins that can be used in the wallet-library: Workers : A worker plugins is a plugin that inherits from Worker class. It distinguish itself by having a execute method that will be executed each workerIntervalTime . Standard : These are mostly enhancers of the wallet library functionalities. Dependencies In order for a plugin to have the ability to access wallet data, you have to add a dependency in the constructor. class MyPlugin extends StandardPlugin { constructor(){ this.dependencies = ['walletId'] } doStruff(){ return this.walletId.substr(0); } } This will allow to access the walletId property; the same thing is doable with the account function. Accessing a plugin wallet.getAccount({index:0}).then((account)=>{ const plugin = account.getPlugin('pluginName'); });","title":"Using a plugin"},{"location":"Wallet-library/plugins/using-a-plugin/#using-a-plugin","text":"","title":"Using a plugin"},{"location":"Wallet-library/plugins/using-a-plugin/#about-plugins","text":"In order to add features and logic to the Wallet-library and be able to share independant module and request them together. Wallet-lib can be passed some plugins at his instantiation. Plugins are particular shaped class that can perform action on your wallet. By default, three plugins are injected : BIP44Worker, SyncWorker and ChainWorker. They handle respectively with maintaining your address pool, getting you in sync with the blockchain and maintaining some knowledge about the chain (blockheight). You can disable them by adding injectDefaultPlugins:false at the initialization parameter of your wallet object. For more granularity, you could do it as a parameter of getAccount(accOpts) .","title":"About plugins"},{"location":"Wallet-library/plugins/using-a-plugin/#type-of-plugins","text":"There are three different types of plugins that can be used in the wallet-library: Workers : A worker plugins is a plugin that inherits from Worker class. It distinguish itself by having a execute method that will be executed each workerIntervalTime . Standard : These are mostly enhancers of the wallet library functionalities.","title":"Type of plugins"},{"location":"Wallet-library/plugins/using-a-plugin/#dependencies","text":"In order for a plugin to have the ability to access wallet data, you have to add a dependency in the constructor. class MyPlugin extends StandardPlugin { constructor(){ this.dependencies = ['walletId'] } doStruff(){ return this.walletId.substr(0); } } This will allow to access the walletId property; the same thing is doable with the account function.","title":"Dependencies"},{"location":"Wallet-library/plugins/using-a-plugin/#accessing-a-plugin","text":"wallet.getAccount({index:0}).then((account)=>{ const plugin = account.getPlugin('pluginName'); });","title":"Accessing a plugin"},{"location":"Wallet-library/plugins/wallet-workers/","text":"Wallet workers In order to perform it's duty of being in-sync with the network and to always keep a pre-generated set of unused addresses, wallet-lib uses internally two workers : - Sync Worker : Used to keep in sync with the network (utxo, received transactions,...) - Chain Worker : Used to keep track of the current chain (best block height,...) - BIP44 Worker : Used to always have a set of 20 unused addresses as per BIP44. Theses default workers can be deactivated by adding the options injectDefaultPlugins to false while initializing your Wallet instance. Start a worker worker.startWorker(); Stop a worker worker.stopWorker(); Sync Worker Events WORKER/SYNC/STARTED - Triggered when the worker is started. WORKER/SYNC/EXECUTED - Triggered each time the worker get executed. BIP 44 Worker Create a BIP44 worker const {events, storage, getAddress} = account; const opts = { events, storage, getAddress } const worker = new BIP44Worker(opts); Events WORKER/BIP44/STARTED - Triggered when the worker is started. WORKER/BIP44/EXECUTED - Triggered each time the worker get executed.","title":"Wallet workers"},{"location":"Wallet-library/plugins/wallet-workers/#wallet-workers","text":"In order to perform it's duty of being in-sync with the network and to always keep a pre-generated set of unused addresses, wallet-lib uses internally two workers : - Sync Worker : Used to keep in sync with the network (utxo, received transactions,...) - Chain Worker : Used to keep track of the current chain (best block height,...) - BIP44 Worker : Used to always have a set of 20 unused addresses as per BIP44. Theses default workers can be deactivated by adding the options injectDefaultPlugins to false while initializing your Wallet instance.","title":"Wallet workers"},{"location":"Wallet-library/plugins/wallet-workers/#start-a-worker","text":"worker.startWorker();","title":"Start a worker"},{"location":"Wallet-library/plugins/wallet-workers/#stop-a-worker","text":"worker.stopWorker();","title":"Stop a worker"},{"location":"Wallet-library/plugins/wallet-workers/#sync-worker","text":"","title":"Sync Worker"},{"location":"Wallet-library/plugins/wallet-workers/#events","text":"WORKER/SYNC/STARTED - Triggered when the worker is started. WORKER/SYNC/EXECUTED - Triggered each time the worker get executed.","title":"Events"},{"location":"Wallet-library/plugins/wallet-workers/#bip-44-worker","text":"","title":"BIP 44 Worker"},{"location":"Wallet-library/plugins/wallet-workers/#create-a-bip44-worker","text":"const {events, storage, getAddress} = account; const opts = { events, storage, getAddress } const worker = new BIP44Worker(opts);","title":"Create a BIP44 worker"},{"location":"Wallet-library/plugins/wallet-workers/#events_1","text":"WORKER/BIP44/STARTED - Triggered when the worker is started. WORKER/BIP44/EXECUTED - Triggered each time the worker get executed.","title":"Events"},{"location":"Wallet-library/plugins/writing-a-new-plugin/","text":"Writing a new plugin There is no control nor monitoring over third-party plugin. So anyone can write it's own plugin. In order for a plugin to have the ability to access wallet data, you have to add a dependency in the constructor. Below, we create a Standard Plugin, see Using a plugin for more information about the different plugin types. const { StandardPlugin } = require('@dashevo/wallet-lib').plugins; class MyWalletConsolidatorPlugin extends StandardPlugin { constructor() { super({ // When true, the wallet instance will only fire \"ready\" when a first execution of the plugin has happen. firstExecutionRequired: false, // Describe if we want to automatically execute it on starting up an account. executeOnStart: false, // Methods and function that we would want to use dependencies: [ 'getUTXOS', 'getUnusedAddress', 'getConfirmedBalance', 'createTransactionFromUTXOS', 'broadcastTransaction', ], }); } consolidateWallet(address = this.getUnusedAddress().address, utxos = this.getUTXOS()) { return { prepareTransaction: () => { if (!utxos || utxos.length === 0) { throw new Error('There is nothing to consolidate'); } const opts = { utxos, recipient: address, }; const rawtx = this.createTransactionFromUTXOS(opts); return { toString: () => rawtx, broadcast: async () => { console.log(`BROADCASTING ${rawtx}`); return self.broadcastTransaction(rawtx); }, }; }, }; } } Using my created plugin When you plugin is created, including it in your Wallet is as easy as referencing up the class in the plugins array. const wallet = new Wallet({ plugins:[MyWalletConsolidatorPlugin] }) When some parameters are required first for your plugin to work, you might also decide to initialize first your plugin like this : const wallet = new Wallet({ plugins:[new MyWalletConsolidatorPlugin({someOptions:true})] }); Accessing secure dependencies Due to the risk from running a plugin that have access to your keychain, these are, by default, not accessible. One would need to initialize a Wallet with the option allowSensitiveOperations set to true . You can see the list of thoses sensitive functions and properties , anything under UNSAFE_* will require this option to be set to true in order to be use from within a plugin. Injection order While system plugins will by default be first injected in the system, in the case of a need for specific injection order. Plugin can be sorted in such a way that in got injected before or after another set of plugins. For this, use injectionOrder properties before and/or after. In below example, this worker will be dependent on the methods getUTXOS to be internally available, and will be expected to be injected before TransactionSyncStreamWorker and after ChainPlugin. class WithInjectBeforeDependenciesWorker extends Worker { constructor() { super({ name: 'withInjectBeforeDependenciesWorker', dependencies: [ 'getUTXOS', ], injectionOrder: { after: [ 'ChainPlugin' ], before: [ 'TransactionSyncStreamWorker' ] } }); } } ``` ## Accessing events From a plugin, you have the ability to listen to account's emitted events. ```js const { EVENT, plugins: { Worker } } = require('@dashevo/wallet-lib'); class NewBlockWorker extends Worker { constructor(options) { super({ name: 'NewBlockWorker', executeOnStart: true, firstExecutionRequired: true, workerIntervalTime: 60 * 1000, gapLimit: 10, dependencies: [ 'storage', 'transport', 'walletId', 'identities', ], ...options, }); } async onStart() { this.parentEvents.on(EVENT.BLOCKHEIGHT_CHANGED, ({payload: blockHeight}) => { // on new blockheight do something. }); } }","title":"Writing a new plugin"},{"location":"Wallet-library/plugins/writing-a-new-plugin/#writing-a-new-plugin","text":"There is no control nor monitoring over third-party plugin. So anyone can write it's own plugin. In order for a plugin to have the ability to access wallet data, you have to add a dependency in the constructor. Below, we create a Standard Plugin, see Using a plugin for more information about the different plugin types. const { StandardPlugin } = require('@dashevo/wallet-lib').plugins; class MyWalletConsolidatorPlugin extends StandardPlugin { constructor() { super({ // When true, the wallet instance will only fire \"ready\" when a first execution of the plugin has happen. firstExecutionRequired: false, // Describe if we want to automatically execute it on starting up an account. executeOnStart: false, // Methods and function that we would want to use dependencies: [ 'getUTXOS', 'getUnusedAddress', 'getConfirmedBalance', 'createTransactionFromUTXOS', 'broadcastTransaction', ], }); } consolidateWallet(address = this.getUnusedAddress().address, utxos = this.getUTXOS()) { return { prepareTransaction: () => { if (!utxos || utxos.length === 0) { throw new Error('There is nothing to consolidate'); } const opts = { utxos, recipient: address, }; const rawtx = this.createTransactionFromUTXOS(opts); return { toString: () => rawtx, broadcast: async () => { console.log(`BROADCASTING ${rawtx}`); return self.broadcastTransaction(rawtx); }, }; }, }; } }","title":"Writing a new plugin"},{"location":"Wallet-library/plugins/writing-a-new-plugin/#using-my-created-plugin","text":"When you plugin is created, including it in your Wallet is as easy as referencing up the class in the plugins array. const wallet = new Wallet({ plugins:[MyWalletConsolidatorPlugin] }) When some parameters are required first for your plugin to work, you might also decide to initialize first your plugin like this : const wallet = new Wallet({ plugins:[new MyWalletConsolidatorPlugin({someOptions:true})] });","title":"Using my created plugin"},{"location":"Wallet-library/plugins/writing-a-new-plugin/#accessing-secure-dependencies","text":"Due to the risk from running a plugin that have access to your keychain, these are, by default, not accessible. One would need to initialize a Wallet with the option allowSensitiveOperations set to true . You can see the list of thoses sensitive functions and properties , anything under UNSAFE_* will require this option to be set to true in order to be use from within a plugin.","title":"Accessing secure dependencies"},{"location":"Wallet-library/plugins/writing-a-new-plugin/#injection-order","text":"While system plugins will by default be first injected in the system, in the case of a need for specific injection order. Plugin can be sorted in such a way that in got injected before or after another set of plugins. For this, use injectionOrder properties before and/or after. In below example, this worker will be dependent on the methods getUTXOS to be internally available, and will be expected to be injected before TransactionSyncStreamWorker and after ChainPlugin. class WithInjectBeforeDependenciesWorker extends Worker { constructor() { super({ name: 'withInjectBeforeDependenciesWorker', dependencies: [ 'getUTXOS', ], injectionOrder: { after: [ 'ChainPlugin' ], before: [ 'TransactionSyncStreamWorker' ] } }); } } ``` ## Accessing events From a plugin, you have the ability to listen to account's emitted events. ```js const { EVENT, plugins: { Worker } } = require('@dashevo/wallet-lib'); class NewBlockWorker extends Worker { constructor(options) { super({ name: 'NewBlockWorker', executeOnStart: true, firstExecutionRequired: true, workerIntervalTime: 60 * 1000, gapLimit: 10, dependencies: [ 'storage', 'transport', 'walletId', 'identities', ], ...options, }); } async onStart() { this.parentEvents.on(EVENT.BLOCKHEIGHT_CHANGED, ({payload: blockHeight}) => { // on new blockheight do something. }); } }","title":"Injection order"},{"location":"Wallet-library/storage/Storage/","text":"Usage : new Storage(opts) Description : This method create a new Storage instance which provide various helper with interacting with atomic elements (tx, address). It connects with the adapter to perform load/save operations. Parameters: opts : parameters type required Description opts.network Network|String no (testnet) The network to use for the Storage instance opts.rehydrate Boolean no (true) If data should be autoloaded from the adapter opts.autosave Boolean no (true) If set at true, will autosave the storage to adapter at an autosaveIntervalTime opts.autosaveIntervalTime Number no (10sec) If millisecond, the interval time at which the adapter should persist the data Returns : Storage instance.","title":"Storage"},{"location":"Wallet-library/storage/addNewTxToAddress/","text":"Usage : storage.addNewTxToAddress(tx, address) Description : Add a specific transaction to the related address. Parameters: parameters type required Description tx Transaction Object yes The Transaction to link to the B58 address address String (b58 address) yes A valid B58 address Returns: Boolean","title":"addNewTxToAddress"},{"location":"Wallet-library/storage/addUTXOToAddress/","text":"Usage : storage.addUTXOToAddress(utxo, address) Description : Link the specified utxo to the related address. Parameters: parameters type required Description utxo UTXO Object yes A valid UTXO address String (b58 address) yes A valid B58 address Returns: Boolean","title":"addUTXOToAddress"},{"location":"Wallet-library/storage/announce/","text":"Usage : storage.announce(type, el) Description : Internal method helper to announce event to the Wallet and Account class. Notes : Listening to accounts.events will transmit those event. Parameters: parameters type required Description type String (event) yes el Object yes Returns: Boolean","title":"Announce"},{"location":"Wallet-library/storage/calculateDuffBalance/","text":"Usage : storage.calculateDuffBalance(walletId, accountIndex, type) Description : Perform a full calculation of the balance of a wallet and account set. Parameters: parameters type required Description walletId String yes The wallet identifier in which we the account is accountIndex Number yes The account index from which we want to perform the calculation type Enum['total', 'confirmed', 'unconfirmed'] no (def: total) Depending of UTXO status, will calculate accordingly Returns: Number (duff - aka satoshis - value of the balance).","title":"calculateDuffBalance"},{"location":"Wallet-library/storage/clearAll/","text":"Usage : storage.clearAll() Description : Clear all data from the store and ask the adapter to store the empty state. Parameters: parameters type required Description Returns: Boolean (saveState).","title":"clearAll"},{"location":"Wallet-library/storage/configure/","text":"Usage : storage.configure(opts) Description : After Storage creation, this method is called to ensure Adapter contains expected method. Notes : This is an internal advanced function called on the startup of a Storage. Parameters: parameters type required Description opts.rehydrate Boolean no Set if the Storage will autoload from the adapter opts.autosave Boolean no Set if the Storage will autosave to the adapter opts.adapter Adapter no The adapter to test and use. Returns: void. Emits: CONFIGURED","title":"Configure"},{"location":"Wallet-library/storage/createChain/","text":"Usage : storage.createChain(network) Description : Create, if not already existing, a chain in the store. Notes : This is an internal advanced function called on the creation of a Wallet. Also, at current state, both testnet and evonet uses the same \"Testnet\" object. Which might cause support issue when using both chain. Parameters: parameters type required Description network Network/String yes The network of the chain to create Returns: Boolean","title":"createChain"},{"location":"Wallet-library/storage/createWallet/","text":"Usage : storage.createWallet(walletId, network, mnemonic, type) Description : Create a wallet in store based on the specified params. Notes : This is an internal advanced function called on the creation of a Wallet. Parameters: parameters type required Description walletId String yes The wallet id to create network Network/String no (Def: testnet) The network for the wallet mnemonic Mnemonic/String no (Def: null) When applicable, the mnemonic used to generate the wallet type String no (Def: null) The wallet type to create Returns: Boolean","title":"createWallet"},{"location":"Wallet-library/storage/getStore/","text":"Usage : storage.getStore() Description : Used to get the whole store. Parameters: parameters type required Description Returns: Full store data","title":"getStore"},{"location":"Wallet-library/storage/getTransaction/","text":"Usage : storage.getTransaction(transactionId) Description : Return the transaction from the store matching the txId. Parameters: parameters type required Description transactionId String yes The transaction id to fetch from the state Returns: TransactionObject Example: storage.getTransaction('4f71db0c4bf3e2769a3ebd2162753b54b33028e3287e45f93c5c7df8bac5ec7e')","title":"getTransaction"},{"location":"Wallet-library/storage/getTransactionMetadata/","text":"Usage : storage.getTransactionMetadata(transactionId) Description : Return the transaction metadata from the store matching the txId. Parameters: parameters type required Description transactionId String yes The transaction id to fetch from the state Returns: TransactionMetadata Example: storage.getTransactionMetadata('4f71db0c4bf3e2769a3ebd2162753b54b33028e3287e45f93c5c7df8bac5ec7e')","title":"getTransactionMetadata"},{"location":"Wallet-library/storage/importAccounts/","text":"Usage : storage.importAccounts(accounts, walletId) Description : Allow to import one or multiple accounts (Account store representation) to the wallet store based on it's walletId. Parameters: parameters type required Description accounts Array[AccountObj] yes The array of account object to import to the store walletId String yes The wallet id to attach the account to Returns: Boolean","title":"importAccounts"},{"location":"Wallet-library/storage/importAddress/","text":"Usage : storage.importAddress(addressObj, walletId) Description : Allow to import one address to the wallet store Parameters: parameters type required Description addressObj AddressObj yes The address object to import to the store walletId String yes The wallet id to attach the address to Returns: Boolean","title":"importAddress"},{"location":"Wallet-library/storage/importAddresses/","text":"Usage : storage.importAddresses(addresses, walletId) Description : Allow to import one or multiple addresses to the wallet Parameters: parameters type required Description addresses Array(addressObj) yes The address object set to import to the store walletId String yes The wallet id to attach the address to Returns: Boolean","title":"importAddresses"},{"location":"Wallet-library/storage/importSingleAddress/","text":"Usage : storage.importSingleAddress(singleAddress, walletId) Description : Allow to import a single address to the wallet Notes : Not useful when managing a HDWallet. Parameters: parameters type required Description singleAddress Object yes The single address object representation to import to the store walletId String yes The wallet id to attach the address to Returns: Boolean","title":"importSingleAddress"},{"location":"Wallet-library/storage/importTransaction/","text":"Usage : storage.importTransaction(transaction, metadata?) Description : Allow to import a transaction to the store. Notes : TransactionObject needs to contains basic vin/vout information. Parameters: parameters type required Description transaction Object/Transaction yes The transaction to import to the store metadata TransactionMetaData no The transaction metadata Returns: Boolean Emits: FETCHED_CONFIRMED_TRANSACTION / FETCHED_UNCONFIRMED_TRANSACTION","title":"importTransaction"},{"location":"Wallet-library/storage/importTransactions/","text":"Usage : storage.importTransactions(transactions) Description : Allow to import a set (array) of transactions to the store. Notes : Uses storage.importTransaction Parameters: parameters type required Description transactions Array[TransactionWithMetadata]/Array[Transaction/Object]/Object yes The set of transactions to import to the store (can be a single element) Returns: Boolean","title":"importTransactions"},{"location":"Wallet-library/storage/rehydrateState/","text":"Usage : async storage.rehydrateState() Description : Used to fetch the state from the persistence adapter Notes : Three items are fetch ( adapter.getItem ) : transactions, wallets and chains data. Parameters: parameters type required Description Returns: Void Emit: REHYDRATE_STATE_SUCCESS/REHYDRATE_STATE_FAILED event","title":"rehydrateState"},{"location":"Wallet-library/storage/saveState/","text":"Usage : async storage.saveState() Description : Used to force persistence of the state to the adapter Notes : Three items are set ( adapter.setItem ) : transactions, wallets and chains data. Parameters: parameters type required Description Returns : Boolean","title":"saveState"},{"location":"Wallet-library/storage/searchAddress/","text":"Usage : storage.searchAddress(address, forceLoop) Description : Returns a specific address information from the store Notes : We maintain mapped (cache) address for easy look-up, forceLoop value allow to outpass that cache and force a slow lookup in the store. Parameters: parameters type required Description address String yes The Address identifier (Base 58 hash representation) to search for forceLoop Boolean no (def: false) Used to bypass the cache and force looping over the addresses Returns : Object ({found, result, type, address, walletId}).","title":"searchAddress"},{"location":"Wallet-library/storage/searchAddressesWithTx/","text":"Usage : storage.searchAddressesWithTx(transactionId) Description : Returns the list of addresses objects that has a relation with the provided TxId. Parameters: parameters type required Description transactionId String yes The Transaction identifier to search for Returns : Object ({found, results, txid}).","title":"searchAddressesWithTx"},{"location":"Wallet-library/storage/searchBlockHeader/","text":"Usage : storage.searchBlockHeader(identifier) Description : Returns the blockHeader matching the provided identifier if it is stored. Parameters: parameters type required Description identifier String/Number yes The BlockHeader identifier (hash or height) to search for Returns : BlockHeader .","title":"searchBlockHeader"},{"location":"Wallet-library/storage/searchTransaction/","text":"Usage : storage.searchTransaction(transactionId) Description : Returns the transaction information from the provided TxId if exists. Parameters: parameters type required Description transactionId String yes The Transaction identifier to search for Returns : Object ({found, result, hash}).","title":"searchTransaction"},{"location":"Wallet-library/storage/searchTransactionMetadata/","text":"Usage : storage.searchTransactionMetadata(transactionId) Description : Returns the transaction metadata from the provided TxId if exists. Parameters: parameters type required Description transactionId String yes The Transaction identifier to search for Returns : Object ({found, result, hash}).","title":"searchTransactionMetadata"},{"location":"Wallet-library/storage/searchWallet/","text":"Usage : storage.searchWallet(walletId) Description : Returns the wallet information from the provided walletId if exists. Parameters: parameters type required Description walletId String yes The Wallet identifier of the wallet containing the address to update Returns : Object ({found, result, walletId}).","title":"searchWallet"},{"location":"Wallet-library/storage/startWorker/","text":"Usage : storage.startWorker() Description : Allow to start the storage worker (uses interval), will save the state when needed. Notes : Use storage.stopWorker() to stop. Parameters: parameters type required Description Returns : void.","title":"startWorker"},{"location":"Wallet-library/storage/stopWorker/","text":"Usage : storage.stopWorker() Description : When the storage worker is running (interval), will clear it stopping further interval to be executed. Parameters: parameters type required Description Returns : Boolean.","title":"stopWorker"},{"location":"Wallet-library/storage/updateAddress/","text":"Usage : async storage.updateAddress(addressObj, walletId) Description : Used to update a specific address of a wallet identified by it's walletId. Parameters: parameters type required Description addressObj AddressObject yes The AddressObject to update (uses address.path as primary key) walletId String yes The Wallet identifier of the wallet containing the address to update Returns : Boolean. Example: storage.updateAddress({ path: \"m/44'/1'/0'/0/0\", index: '0', address: 'yLhsYLXW5sFHLDPLj2EHgrmQRhP712ANda', transactions: [], balanceSat: 0, unconfirmedBalanceSat: 0, utxos: {}, fetchedLast: 0, used: true, }, \"a3771aaf93\");","title":"updateAddress"},{"location":"Wallet-library/storage/updateTransaction/","text":"Usage : storage.updateTransaction(transaction) Description : Internally, this is mostly called to update the information of a transaction in the store. Works mostly more as an replace than an update. Parameters: parameters type required Description transaction Transaction yes The Transaction to update (uses tx.hash as key) Returns : Boolean. Example: const { Transaction } = require('@dashevo/dashcore-lib'); const transaction = new Transaction({ hash: '9b4a34096f2270f70d8e0ba91094eb37535349f80874f8440e74c0567ef82680', version: 3, inputs: [ { prevTxId: '9f398515b6fc898ebf4e7b49bbfc4359b8c89f508c6cd677e53946bd86064b28', outputIndex: 0, sequenceNumber: 4294967295, script: '47304402205bb4f7880fb0fc13218940ba341c30e817363e5590343d28639af921b2a5f1d40220010920ae4b00bbb657f8653cb44172b8cb13447bb5105ddaf32a2845ea0666b90121025ae98eff89505fa5ff60f919ae690de638d31f4f2fcab9a9deeaf4d48eda794b', scriptString: '71 0x304402205bb4f7880fb0fc13218940ba341c30e817363e5590343d28639af921b2a5f1d40220010920ae4b00bbb657f8653cb44172b8cb13447bb5105ddaf32a2845ea0666b901 33 0x025ae98eff89505fa5ff60f919ae690de638d31f4f2fcab9a9deeaf4d48eda794b' } ], outputs: [ { satoshis: 4294967000, script: '76a9143ec33076ba72b36b66b7ec571dd7417abdeb76f888ac' } ], nLockTime: 0 }) storage.updateTransaction(transaction);","title":"updateTransaction"},{"location":"Wallet-library/usage/coinSelection/","text":"Coin Selection Purpose In order to decide which set of input to use for making payments, wallet-lib use the coin selection helper which will decide which unspent transaction output (UTXO) to select. Strategies There are multiples strategy algorithms provided with Wallet-lib, that you can chose from. Strategy Description simpleDescendingAccumulator Will maximize the uses of big inputs to meet the amount required. Allows the fee to be optimized for the smallest size at the cost of breaking big inputs. simpleAscendingAccumulator Will try to use as many small inputs as possible to meet the amount required. Allows using many small inputs at the cost of a potentially bigger fee. By default, the algorithm that is being used is simpleDescendingAccumulator . See Account.createTransaction() for more information about how to select one during transaction creation. Additionally, you can also require the utility function const coinSelection = require('@dashevo/wallet-lib/src/utils/coinSelection.js') for your own usage. const utxosList = account.getUTXOS(); const outputsList = [{ address:'XmjeE...', satoshis:1200000 }] const coinSelection = coinSelection(utxosList, outputsList); const selectedUTXO = coinSelection(utxosList, outputsList); Implement your own algorithm By creating a simple function algorithm that you pass to the createTransaction parameter, you can provide your own algorithm that will be used to the coinSelection. To implements your own algorithm, you might want to take example on the already existing one . You will need your algorithm to handle multiples parameter : utxosList - An array consisting of multiple unspent output . outputsList - An array consisting of multiple Output . deductFee - A simple boolean that indicates if we want to deduct fee from our outputs. (Can be useful for a control on how much we wish to spend at maximum). feeCategory - A simple enum of the fee category (normal, slow, fast,...). Your algorithm will be required to return the following object structure : utxos : An array consisting of the final selection of UTXOs. outputs : An array consisting of the final outputs (which might have been modified in case of deductFee being true ). estimatedFee : A duff value of the fee estimated for such transaction. utxosValue : The total accumulated duffs value of the used UTXOs. feeCategory","title":"Coin Selection"},{"location":"Wallet-library/usage/coinSelection/#coin-selection","text":"","title":"Coin Selection"},{"location":"Wallet-library/usage/coinSelection/#purpose","text":"In order to decide which set of input to use for making payments, wallet-lib use the coin selection helper which will decide which unspent transaction output (UTXO) to select.","title":"Purpose"},{"location":"Wallet-library/usage/coinSelection/#strategies","text":"There are multiples strategy algorithms provided with Wallet-lib, that you can chose from. Strategy Description simpleDescendingAccumulator Will maximize the uses of big inputs to meet the amount required. Allows the fee to be optimized for the smallest size at the cost of breaking big inputs. simpleAscendingAccumulator Will try to use as many small inputs as possible to meet the amount required. Allows using many small inputs at the cost of a potentially bigger fee. By default, the algorithm that is being used is simpleDescendingAccumulator . See Account.createTransaction() for more information about how to select one during transaction creation. Additionally, you can also require the utility function const coinSelection = require('@dashevo/wallet-lib/src/utils/coinSelection.js') for your own usage. const utxosList = account.getUTXOS(); const outputsList = [{ address:'XmjeE...', satoshis:1200000 }] const coinSelection = coinSelection(utxosList, outputsList); const selectedUTXO = coinSelection(utxosList, outputsList);","title":"Strategies"},{"location":"Wallet-library/usage/coinSelection/#implement-your-own-algorithm","text":"By creating a simple function algorithm that you pass to the createTransaction parameter, you can provide your own algorithm that will be used to the coinSelection. To implements your own algorithm, you might want to take example on the already existing one . You will need your algorithm to handle multiples parameter : utxosList - An array consisting of multiple unspent output . outputsList - An array consisting of multiple Output . deductFee - A simple boolean that indicates if we want to deduct fee from our outputs. (Can be useful for a control on how much we wish to spend at maximum). feeCategory - A simple enum of the fee category (normal, slow, fast,...). Your algorithm will be required to return the following object structure : utxos : An array consisting of the final selection of UTXOs. outputs : An array consisting of the final outputs (which might have been modified in case of deductFee being true ). estimatedFee : A duff value of the fee estimated for such transaction. utxosValue : The total accumulated duffs value of the used UTXOs. feeCategory","title":"Implement your own algorithm"},{"location":"Wallet-library/usage/dapi/","text":"About DAPI DAPI (Decentralized API) is a distributed and decentralized endpoints provided by the Masternode Network. You can learn more about DAPI on the DAPI-Client documentation . Get the DAPI-Client instance When the Wallet-lib is initialized without any transporter, Wallet-lib will by default use DAPI-Client as a transporter. You can fetch the current instance of DAPI directly from the wallet : const wallet = new Wallet(); const client = wallet.transport; Modify the seeds By using your own DAPI-Client instance and passing it to the Wallet constructor (using transport argument). You can specify your own seeds to connect to. const DAPIClient = require('@dashevo/dapi-client'); const { Wallet } = require('./src'); const DAPIClientTransport = require('./src/transport/DAPIClientTransport/DAPIClientTransport.js'); const client = new DAPIClient({ seeds: [{ service: '18.236.131.253:3000' }], timeout: 20000, retries: 5, }); const transport = new DAPIClientTransport(client); const wallet = new Wallet({ transport });","title":"Dapi"},{"location":"Wallet-library/usage/dapi/#about-dapi","text":"DAPI (Decentralized API) is a distributed and decentralized endpoints provided by the Masternode Network. You can learn more about DAPI on the DAPI-Client documentation .","title":"About DAPI"},{"location":"Wallet-library/usage/dapi/#get-the-dapi-client-instance","text":"When the Wallet-lib is initialized without any transporter, Wallet-lib will by default use DAPI-Client as a transporter. You can fetch the current instance of DAPI directly from the wallet : const wallet = new Wallet(); const client = wallet.transport;","title":"Get the DAPI-Client instance"},{"location":"Wallet-library/usage/dapi/#modify-the-seeds","text":"By using your own DAPI-Client instance and passing it to the Wallet constructor (using transport argument). You can specify your own seeds to connect to. const DAPIClient = require('@dashevo/dapi-client'); const { Wallet } = require('./src'); const DAPIClientTransport = require('./src/transport/DAPIClientTransport/DAPIClientTransport.js'); const client = new DAPIClient({ seeds: [{ service: '18.236.131.253:3000' }], timeout: 20000, retries: 5, }); const transport = new DAPIClientTransport(client); const wallet = new Wallet({ transport });","title":"Modify the seeds"},{"location":"Wallet-library/usage/events/","text":"Events const {EVENTS} = require('@dashevo/wallet-lib'); const {FETCHED_CONFIRMED_TRANSACTION} = EVENTS; const doSomethingConfirmedTransactionFetched = (tx) => {...} account.on(FETCHED_CONFIRMED_TRANSACTION, doSomethingConfirmedTransactionFetched); Events types : Storage Event Name Description CONFIGURED throwed when Storage has configured the adapter. REHYDRATE_STATE_FAILED onFailedRehydrateState REHYDRATE_STATE_SUCCESS throwed when Storage has succesfully rehydrated the data General Event Name Description READY throwed when ready to be used Sync Info Event Name Description BLOCKHEIGHT_CHANGED When the chain has moved from one block forward FETCHED_UNCONFIRMED_TRANSACTION When we got to fetch an unconfirmed transaction, we throw this event FETCHED_CONFIRMED_TRANSACTION This one is if the transaction is confirmed FETCHED_TRANSACTIONS In both case, we throw that event Balance Event Name Description UNCONFIRMED_BALANCE_CHANGED When unconfirmed balance change, we gives the delta + totalValue BALANCE_CHANGED When the balance change, we gives the delta + totalValue","title":"Events"},{"location":"Wallet-library/usage/events/#events","text":"const {EVENTS} = require('@dashevo/wallet-lib'); const {FETCHED_CONFIRMED_TRANSACTION} = EVENTS; const doSomethingConfirmedTransactionFetched = (tx) => {...} account.on(FETCHED_CONFIRMED_TRANSACTION, doSomethingConfirmedTransactionFetched); Events types :","title":"Events"},{"location":"Wallet-library/usage/events/#storage","text":"Event Name Description CONFIGURED throwed when Storage has configured the adapter. REHYDRATE_STATE_FAILED onFailedRehydrateState REHYDRATE_STATE_SUCCESS throwed when Storage has succesfully rehydrated the data","title":"Storage"},{"location":"Wallet-library/usage/events/#general","text":"Event Name Description READY throwed when ready to be used","title":"General"},{"location":"Wallet-library/usage/events/#sync-info","text":"Event Name Description BLOCKHEIGHT_CHANGED When the chain has moved from one block forward FETCHED_UNCONFIRMED_TRANSACTION When we got to fetch an unconfirmed transaction, we throw this event FETCHED_CONFIRMED_TRANSACTION This one is if the transaction is confirmed FETCHED_TRANSACTIONS In both case, we throw that event","title":"Sync Info"},{"location":"Wallet-library/usage/events/#balance","text":"Event Name Description UNCONFIRMED_BALANCE_CHANGED When unconfirmed balance change, we gives the delta + totalValue BALANCE_CHANGED When the balance change, we gives the delta + totalValue","title":"Balance"},{"location":"Wallet-library/usage/examples/","text":"Examples Offline cold-wallet usage : The wallet can handle a lack of connectivity. This could allow the use of the wallet library in an offline way. Such uses case would be to generate a bunch of addresses that you could manually import into a database (for rolling incoming addresses) You also have ways to import a known address, transaction, account or any type of data that you could wish to have via the network, thus allowing you to use the wallet-library without connectivity. See here sample code Offline message signing : See here sample code Client usage From Mnemonic: sample code From PrivateKey: sample code","title":"Examples"},{"location":"Wallet-library/usage/examples/#examples","text":"","title":"Examples"},{"location":"Wallet-library/usage/examples/#offline-cold-wallet-usage","text":"The wallet can handle a lack of connectivity. This could allow the use of the wallet library in an offline way. Such uses case would be to generate a bunch of addresses that you could manually import into a database (for rolling incoming addresses) You also have ways to import a known address, transaction, account or any type of data that you could wish to have via the network, thus allowing you to use the wallet-library without connectivity. See here sample code","title":"Offline cold-wallet usage :"},{"location":"Wallet-library/usage/examples/#offline-message-signing","text":"See here sample code","title":"Offline message signing :"},{"location":"Wallet-library/usage/examples/#client-usage","text":"From Mnemonic: sample code From PrivateKey: sample code","title":"Client usage"},{"location":"Wallet-library/utils/calculateTransactionFees/","text":"Usage : calculateTransactionFees(transaction) Description : Return for a transaction, the fee value that were used Notes : To calculate the fee, provided transaction's input require output knowledge to be supplied Parameters: parameters type required Description transaction Transaction yes A transaction instance Returns : {number} - fee value used for this transaction","title":"calculateTransactionFees"},{"location":"Wallet-library/utils/categorizeTransactions/","text":"Usage : categorizeTransactions() Description : Return for a transaction, the fee value that were used Parameters: parameters type required Description transactionsWithMetadata [TransactionMetadata] yes Transaction with their metadata accountStore Object yes Account store with addresses accountIndex Number yes The account index walletType WALLET_TYPES yes The wallet type network Network/String no (def: testnet) Wallet network Returns : {[CategorizedTransaction]} - Array of categorized transactions const categorizedTransactions = categorizeTransaction(transactionsWithMetadata, accountstore, 0, WALLET_TYPES.HDWALLET); [{ transaction: Transaction(), type: 'received', from: [{}], to: [{}], blockHash: '00001' height: 42, isInstantLocked: true, isChainLocked: true }]","title":"categorizeTransactions"},{"location":"Wallet-library/utils/classifyAddresses/","text":"Usage : classifyAddresses(addressStore, accountIndex, walletType) Description : Return for an addressStore, accountIndex and wallet type, the array classified set of addresses Parameters: parameters type required Description addressStore Object yes Account store with addresses accountIndex Number yes The account index walletType WALLET_TYPES yes The wallet type Returns : {[ClassifiedAddresses]} - Array of classified addresses const classifiedAddresses = classifyAddresses(addressStore, 0, WALLET_TYPES.HDWALLET); { externalAddressList: [ 'yd1ohc12LgCYp56CDuckTEHwoa6LbPghMd', '...' ], internalAddressList: [ 'yaLhoAZ4iex2zKmfvS9rvEmxXmRiPrjHdD', '...' ], otherAccountAddressList: [] };","title":"classifyAddresses"},{"location":"Wallet-library/utils/coinSelection/","text":"Usage : coinSelection(utxosList, outputsList, deductFee, feeCategory, strategy) Description : For a provided outputsList will select the best utxos from utxosList matching the fees and strategy requirements Parameters: parameters type required Description utxosList [UTXO] yes Account store with addresses outputsList [Output] yes The account index deductFee Boolean no (def: false) The wallet type feeCategory FeeCategory no (def: normal) The wallet type strategy Strategy no (def: simpleDescendingAccumulator) The wallet type Returns : {[ClassifiedAddresses]} - Array of classified addresses coinSelection(utxosList, outputsList, true); { utxos, outputs, feeCategory, estimatedFee, utxosValue, }","title":"coinSelection"},{"location":"Wallet-library/utils/dashToDuffs/","text":"Usage : dashToDuffs(dash) Description : For a dash value, returns value in duffs Parameters: parameters type required Description dash Number yes Value input in dash Returns : {Number} - Value in duffs (satoshis) dashToDuffs(1); //returns 100000000","title":"dashToDuffs"},{"location":"Wallet-library/utils/duffsToDash/","text":"Usage : duffsToDash(duffs) Description : For a duff value, returns value in Dash Parameters: parameters type required Description duffs Number yes Value input in duff Returns : {Number} - Value in dash duffsToDash(100000000); //returns 1","title":"duffsToDash"},{"location":"Wallet-library/utils/extendTransactionsWithMetadata/","text":"Usage : extendTransactionsWithMetadata(addressStore, accountIndex, walletType) Description : Return for an addressStore, accountIndex and wallet type, the array classified set of addresses Parameters: parameters type required Description addressStore Object yes Account store with addresses accountIndex Number yes The account index walletType WALLET_TYPES yes The wallet type Returns : {[TransactionsWithMetadata]} - Array of transactions with metadata addresses extendTransactionsWithMetadata(transactions, transactionsMetadata); [ [ Transaction, { blockHash: '0000012cf6377c6cf2b317a4deed46573c09f04f6880dca731cc9ccea6691e19', height: 555508, instantLocked: true, chainLocked: true } ] ];","title":"extendTransactionsWithMetadata"},{"location":"Wallet-library/utils/filterTransactions/","text":"Usage : filterTransactions(accountStore, walletType, accountIndex, transactions) Description : Parameters: parameters type required Description addressStore Object yes Account store with addresses accountIndex Number yes The account index walletType WALLET_TYPES yes The wallet type Returns : {[Transaction]} - Array of transaction filtered filterTransactions(accountStore, walletType, accountIndex, transactions); [Transaction,...];","title":"filterTransactions"},{"location":"Wallet-library/utils/getBytesOf/","text":"Usage : getBytesOf(value, type) Description : For a provided type and value, returns the bytes value of it Notes : Used for transaction size calculation for fee estimation Parameters: parameters type required Description value Output/UTXO yes Value input in dash type Output/UTXO yes Value input in dash Returns : {Number} - Bytes value","title":"getBytesOf"},{"location":"Wallet-library/utils/mnemonic/generateNewMnemonic/","text":"Usage : generateNewMnemonic() Description : Generate a new random mnemonic Parameters: parameters type required Description Returns : {Mnemonic}","title":"generateNewMnemonic"},{"location":"Wallet-library/utils/mnemonic/mnemonicToHDPrivateKey/","text":"Usage : mnemonicToHDPrivateKey(mnemonic) Description : Parameters: parameters type required Description mnemonic Mnemonic yes A mnemonic Returns : {HDPrivateKey}","title":"mnemonicToHDPrivateKey"},{"location":"Wallet-library/utils/mnemonic/mnemonicToSeed/","text":"Usage : mnemonicToSeed(mnemonic, password) Description : Generate the seed from mnemonic Parameters: parameters type required Description mnemonic Mnemonic yes A mnemonic password string no Returns : {String} hex seed","title":"mnemonicToSeed"},{"location":"Wallet-library/utils/mnemonic/mnemonicToWalletId/","text":"Usage : mnemonicToWalletId(mnemonic) Description : Generate the deterministic wallet id based on mnemonic Parameters: parameters type required Description mnemonic Mnemonic yes A mnemonic Returns : {String} hex wallet id","title":"mnemonicToWalletId"},{"location":"Wallet-library/utils/mnemonic/seedToHDPrivateKey/","text":"Usage : seedToHDPrivateKey(seed) Description : Parameters: parameters type required Description seed Mnemonic yes A mnemonic Returns : {HDPrivateKey}","title":"seedToHDPrivateKey"},{"location":"Wallet-library/wallet/Wallet/","text":"Usage : new Wallet(walletOpts) Description : This method creates a new Wallet. In Wallet-Lib, a Wallet is a manager that is tied to a passphrase/seed or privateKey and manage one or multiples Account from that. It's purpose is mainly to create or get an account, allowing multiple account to be tracked and tied from a single manager. Parameters: parameters type required Description walletOpts.network string/Network no (def:'testnet') Use either a string reference to Networks ('livenet', 'testnet') or it's Networks representation walletOpts.mnemonic string/Mnemonic no If sets at null, generate a new mnemonic. If sets to a valid value, create wallet from mnemonic walletOpts.passphrase string no If sets at null, generate a new privateKey. It sets to a valid privateKey, uses it (with the passphrase if provided) to unlock the seed walletOpts.offlineMode boolean no (def: false) Set to true to not perform any request to the network walletOpts.injectDefaultPlugins boolean no (def: true) Use to inject default plugins on loadup (BIP44Worker, ChainWorker and SyncWorker) walletOpts.allowSensitiveOperations boolean no (def: false) If you want a special plugin to access the keychain or other sensitive operation, set this to true. walletOpts.cache.addresses object no If you have your cache state somewhere else (fs) you can fetch and pass it along for faster sync-up walletOpts.cache.transactions object no If you have your cache state somewhere else (fs) you can fetch and pass it along for faster sync-up walletOpts.plugins Array no It you have some plugins, worker you want to pass to wallet-lib. You can pass them as constructor or initialized object walletOpts.seed string no If you only have a seed representation, you can pass it instead of mnemonic to init the wallet from it walletOpts.HDPrivateKey string/HDPrivateKey no If you only have a HDPrivateKey representation, you can pass it instead of mnemonic to init the wallet from it walletOpts.HDPublicKey string/HDPublicKey no If you only have a HDPublicKey representation, you can pass it instead of mnemonic to init the wallet from it walletOpts.privateKey string/PrivateKey no If you only have a PrivateKey representation, you can pass it instead of mnemonic to init the wallet from it walletOpts.publicKey string/PublicKey no If you only have a PublicKey representation, you can pass it instead of mnemonic to init the wallet from it N.B 1 : If both mnemonic, seed and privateKey are filled, only mnemonic will be used. If none is entered, the wallet will create a mnemonic. N.B 2 : When initialized from a privateKey , publicKey or an HDPublicKey , comportment of Wallet-lib differs slightly. PrivateKey : There is no path in this mode. It's a unique public address. PrivateKey : There is no path in this mode. It's a unique public address. Watch-only. HDPublicKey : There is no signing in this mode. Watch-only. Returns : Wallet instance. Examples : Creation without a mnemonic (gets one generated) const wallet = new Wallet(); or const wallet = new Wallet({ mnemonic: null }); console.log(wallet.exportWallet()); In the case where you will want to have stronger entropy (have 24 words generated instead of 12), this snippet will allow to do that : const { Mnemonic } = require('@dashevo/dashcore-lib'); const mnemonic = new Mnemonic(256).toString(); Creation from Mnemonic const wallet = new Wallet({ mnemonic: 'hole lesson insane entire dolphin scissors game dwarf polar ethics drip math' }) Creation from HDPrivateKey const wallet = new Wallet({ HDPrivateKey: 'tprv8ZgxMBicQKsPeWisxgPVWiXho8ozsAUqc3uvpAhBuoGvSTxqkxPZbTeG43mvgXn3iNfL3cBL1NmR4DaVoDBPMUXe1xeiLoc39jU9gRTVBd2' }) Creation from HDPublicKey const wallet = new Wallet({ HDPublicKey: 'tpubDEB6BgW9JvZRWVbFmwwGuJ2vifakABuxQWdY9yXbFC2rc3zagie1RkhwUEnahb1dzaapchEVeKqKcx99TzkjNvjXcmoQkLJwsYnA1J5bGNj' }) Creation from Seed const wallet = new Wallet({ seed: '436905e6756c24551bffaebe97d0ebd51b2fa027e838c18d45767bd833b02a80a1dd55728635b54f2b1dbed5963f4155e160ee1e96e2d67f7e8ac28557d87d96' }) Creation from privateKey const wallet = new Wallet({ privateKey: 'cR4t6evwVZoCp1JsLk4wURK4UmBCZzZotNzn9T1mhBT19SH9JtNt' }) Creation from publicKey const wallet = new Wallet({ HDPublicKey: 'tpubDEB6BgW9JvZRWVbFmwwGuJ2vifakABuxQWdY9yXbFC2rc3zagie1RkhwUEnahb1dzaapchEVeKqKcx99TzkjNvjXcmoQkLJwsYnA1J5bGNj' })","title":"Wallet"},{"location":"Wallet-library/wallet/Wallet/#creation-without-a-mnemonic-gets-one-generated","text":"const wallet = new Wallet(); or const wallet = new Wallet({ mnemonic: null }); console.log(wallet.exportWallet()); In the case where you will want to have stronger entropy (have 24 words generated instead of 12), this snippet will allow to do that : const { Mnemonic } = require('@dashevo/dashcore-lib'); const mnemonic = new Mnemonic(256).toString();","title":"Creation without a mnemonic (gets one generated)"},{"location":"Wallet-library/wallet/Wallet/#creation-from-mnemonic","text":"const wallet = new Wallet({ mnemonic: 'hole lesson insane entire dolphin scissors game dwarf polar ethics drip math' })","title":"Creation from Mnemonic"},{"location":"Wallet-library/wallet/Wallet/#creation-from-hdprivatekey","text":"const wallet = new Wallet({ HDPrivateKey: 'tprv8ZgxMBicQKsPeWisxgPVWiXho8ozsAUqc3uvpAhBuoGvSTxqkxPZbTeG43mvgXn3iNfL3cBL1NmR4DaVoDBPMUXe1xeiLoc39jU9gRTVBd2' })","title":"Creation from HDPrivateKey"},{"location":"Wallet-library/wallet/Wallet/#creation-from-hdpublickey","text":"const wallet = new Wallet({ HDPublicKey: 'tpubDEB6BgW9JvZRWVbFmwwGuJ2vifakABuxQWdY9yXbFC2rc3zagie1RkhwUEnahb1dzaapchEVeKqKcx99TzkjNvjXcmoQkLJwsYnA1J5bGNj' })","title":"Creation from HDPublicKey"},{"location":"Wallet-library/wallet/Wallet/#creation-from-seed","text":"const wallet = new Wallet({ seed: '436905e6756c24551bffaebe97d0ebd51b2fa027e838c18d45767bd833b02a80a1dd55728635b54f2b1dbed5963f4155e160ee1e96e2d67f7e8ac28557d87d96' })","title":"Creation from Seed"},{"location":"Wallet-library/wallet/Wallet/#creation-from-privatekey","text":"const wallet = new Wallet({ privateKey: 'cR4t6evwVZoCp1JsLk4wURK4UmBCZzZotNzn9T1mhBT19SH9JtNt' })","title":"Creation from privateKey"},{"location":"Wallet-library/wallet/Wallet/#creation-from-publickey","text":"const wallet = new Wallet({ HDPublicKey: 'tpubDEB6BgW9JvZRWVbFmwwGuJ2vifakABuxQWdY9yXbFC2rc3zagie1RkhwUEnahb1dzaapchEVeKqKcx99TzkjNvjXcmoQkLJwsYnA1J5bGNj' })","title":"Creation from publicKey"},{"location":"Wallet-library/wallet/createAccount/","text":"Usage : await wallet.createAccount(accountOpts) Description : This method, equivalent of a new Account(wallet, accountOpts) will create a new account having the specified options. Parameters: See the Account constructor parameters. N.B : You also probably mean to use .getAccount() instead. This is designed mostly to be Private as get an account deal with it. Returns : void.","title":"createAccount"},{"location":"Wallet-library/wallet/disconnect/","text":"Usage : wallet.disconnect() Description : This method will disconnect all accounts, plugins and other workers (Storage). Useful to release all worker when doing integration testing with Wallet/Account Parameters: parameters type required Description Returns : void.","title":"Disconnect"},{"location":"Wallet-library/wallet/dumpStorage/","text":"Usage : wallet.dumpStorage([opts]) Description : Method dumps the state of the storage in JSON format Warning : Storage dump may contain sensitive data. Please, do not share the output of this function for mainnet wallets. Parameters: parameters type required Description opts.log Boolean no Indicates whether storage should be logged in the console Returns : {String}","title":"dumpStorage"},{"location":"Wallet-library/wallet/exportWallet/","text":"Usage : wallet.exportWallet([outputType]) Description : This method will export the wallet to the default outputType (depending on initializated params : mnemonic. HDPubKey,...). This method varies depending from which type of wallet is this. - When init from a mnemonic, by default return mnemonic but support 'HDPrivateKey' - When init from a seed, by default returns and only support HDPrivateKey - When init from a private key, by default returns and only support PrivateKey. Parameters: parameters type required Description outputType String no The required output type of the exported wallet Returns : {Mnemonic|HDPrivateKey|HDPublicKey|PrivateKey}","title":"exportWallet"},{"location":"Wallet-library/wallet/fromHDPrivateKey/","text":"Usage : wallet.fromHDPrivateKey(HDPrivateKey) Description : Initialize a Wallet from a HDPrivateKey representation. Notes : This is an internal method, in the future, when TC39 proposal pass, we will use the private markup. Parameters: parameters type required Description HDPrivateKey HDPrivateKey String yes Returns : void (set a HD Wallet). Examples : wallet.fromHDPrivateKey('xprv9s21ZrQH143K37d2j9YW7snYGbAJJX9vzEZRwU7QEc4yP39t1Yc7t2Aw79aBBQWfLNqnpo9bFRnWoDv7xCPyBpLFHZvvrtVYfRv2zEBtnT5')","title":"fromHDPrivateKey"},{"location":"Wallet-library/wallet/fromHDPublicKey/","text":"Usage : wallet.fromHDPublicKey(HDPublicKey) Description : Initialize a Wallet from a HDPublicKey representation. Notes : This is an internal method, in the future, when TC39 proposal pass, we will use the private markup. Parameters: parameters type required Description HDPublicKey HDPublicKey String yes Returns : void (set a HD Wallet in watch mode). Examples : wallet.fromHDPrivateKey('tpubDEB6BgW9JvZRWVbFmwwGuJ2vifakABuxQWdY9yXbFC2rc3zagie1RkhwUEnahb1dzaapchEVeKqKcx99TzkjNvjXcmoQkLJwsYnA1J5bGNj')","title":"fromHDPublicKey"},{"location":"Wallet-library/wallet/fromMnemonic/","text":"Usage : wallet.fromMnemonic(mnemonic) Description : Initialize a Wallet from a Mnemonic representation. Notes : This is an internal method, in the future, when TC39 proposal pass, we will use the private markup. Mnemonic initialized wallet works a little differently as they store the mnemonic in the wallet object. Parameters: parameters type required Description mnemonic Mnemonic String yes Returns : void (set a HD Wallet). Examples : wallet.fromMnemonic('knife easily prosper input concert merge prepare autumn pen blood glance toilet')","title":"fromMnemonic"},{"location":"Wallet-library/wallet/fromPrivateKey/","text":"Usage : wallet.fromPrivateKey(privateKey) Description : Initialize a Wallet from a PrivateKey representation. Notes : This is an internal method, in the future, when TC39 proposal pass, we will use the private markup. Parameters: parameters type required Description PrivateKey PrivateKey String yes Returns : void (set a single address wallet). Examples : wallet.fromPrivateKey('cR4t6evwVZoCp1JsLk4wURK4UmBCZzZotNzn9T1mhBT19SH9JtNt')","title":"fromPrivateKey"},{"location":"Wallet-library/wallet/fromSeed/","text":"Usage : wallet.fromSeed(seed) Description : Initialize a Wallet from a seed. Notes : This is an internal method, in the future, when TC39 proposal pass, we will use the private markup. Notes 2 : This actually transform seed in HDPrivateKey and uses wallet.fromHDPrivateKey() . Parameters: parameters type required Description seed String yes The seed from which you want to initialize the wallet. Returns : void (set a HD wallet). Examples : wallet.fromSeed('9e55e5cb0e2fe273600cf5af7d7760fe569121c320395f0233202b97445e54f577d5a706c49aa1f3f0993d2ff97e2e6d63e4ccd0b7e9d4c4f115ae58957a9114')","title":"fromSeed"},{"location":"Wallet-library/wallet/generateNewWalletId/","text":"Usage : wallet.generateNewWalletId() Description : Internally, each wallet has a WalletId attached. This tries to be deterministic by actually just be a substring of a double sha256 hash from the input. Notes : This is an internal method, in the future, when TC39 proposal pass, we will use the private markup. Also, mutates Wallet.walletId. Parameters: parameters type required Description Returns : String (wallet.walletId).","title":"generateNewWalletId"},{"location":"Wallet-library/wallet/getAccount/","text":"Usage : await wallet.getAccount([opts]) Description : This method will get you the account specified by it's index. Parameters: parameters type required Description opts.index number no (default: 0) The BIP44 index Returns : Account. N.B: When getAccount is called on a never initialized account, you can pass-it any of Account options , and the wallet will initiate it (.createAccount) for you with those passed params and returns you the account.","title":"getAccount"}]}